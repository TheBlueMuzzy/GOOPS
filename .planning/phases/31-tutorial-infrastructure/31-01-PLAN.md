---
phase: 31-tutorial-infrastructure
plan: 01
type: execute
---

<objective>
Build the tutorial state machine, localStorage persistence, and event bus hooks that all tutorial features depend on.

Purpose: Establish the data layer and event infrastructure so Plans 02 and 03 can build UI on top of a working state system.
Output: useTutorial hook, extended SaveData, new GameEventType entries, tutorial types.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Key source files:
@utils/storage.ts
@core/events/GameEvents.ts
@core/events/EventBus.ts
@types.ts
@hooks/useGameEngine.ts
@App.tsx
@Game.tsx

**Design decisions (from STATE.md):**
- Rank IS the tutorial gate — no separate tutorial progression
- Multiple rank 0 training levels (0TA, 0TB, 0TC)
- Max 1 tooltip per game (non-blocking during gameplay)
- 8 words max per instruction
- Multi-modal delivery: intercom pop-ups, HUD hints, console glow, journal entries

**Established patterns:**
- EventBus: singleton `gameEventBus` with `.on()` / `.emit()`, typed payloads
- localStorage: `gooptris_save_v3` key, SaveData interface, loadSaveData/saveGameData API
- Hooks: `use*.ts` in hooks/ directory, useState + useEffect + event subscriptions
- Types: all in `types.ts`, PascalCase interfaces/enums
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tutorial types and state machine</name>
  <files>types/tutorial.ts, hooks/useTutorial.ts</files>
  <action>
Create `types/tutorial.ts` with:

```
TutorialStepId — string union of all tutorial step identifiers (e.g., 'WELCOME', 'ROTATE_INTRO', 'DROP_INTRO', 'CRACK_INTRO', 'POP_TIMING', 'WRAP_INTRO', 'FIRST_SHIFT'). Keep extensible — these are the rank 0 training steps. Also add placeholder IDs for future phases: 'COMPLICATION_LIGHTS', 'COMPLICATION_LASER', 'COMPLICATION_CONTROLS', 'UPGRADE_INTRO', 'ABILITY_INTRO'.

TutorialStep — interface { id: TutorialStepId; rank: number; trigger: TutorialTrigger; message: IntercomMessage; requiresAction?: string; autoAdvanceMs?: number; }

TutorialTrigger — discriminated union:
  { type: 'ON_RANK_REACH'; rank: number }
  | { type: 'ON_EVENT'; event: GameEventType }
  | { type: 'ON_GAME_START'; rank: number }
  | { type: 'ON_FIRST_ACTION'; action: string }
  | { type: 'MANUAL' }

IntercomMessage — interface { keywords: string[]; fullText: string; } (keywords are the words that render clearly through static; fullText is the complete message)

TutorialState — interface { activeStep: TutorialStepId | null; completedSteps: TutorialStepId[]; dismissed: boolean; }
```

Create `hooks/useTutorial.ts`:
- Takes `rank: number`, `isSessionActive: boolean` as params
- Manages TutorialState with useState
- Loads completed steps from SaveData on mount
- Exposes: `activeStep: TutorialStep | null`, `completeStep()`, `dismissStep()`, `isStepCompleted(id): boolean`
- `completeStep()` adds step to completedSteps, saves to localStorage, clears activeStep
- `dismissStep()` sets dismissed=true, clears activeStep (does NOT mark complete — will re-trigger)
- Subscribes to gameEventBus for ON_EVENT triggers
- Checks rank-based triggers when rank changes
- Only activates steps that haven't been completed yet
- Does NOT define the actual tutorial content — just the state machine. Content will be defined in Phase 33 (Rank 0 Training Sequence). For now, include a `TUTORIAL_STEPS: TutorialStep[]` array in a separate `data/tutorialSteps.ts` file with just 1-2 placeholder steps for testing (e.g., a WELCOME step that triggers ON_GAME_START at rank 0).
  </action>
  <verify>TypeScript compiles with no errors: `npx tsc --noEmit`</verify>
  <done>TutorialStep/TutorialState types exist, useTutorial hook compiles, placeholder step data exists in data/tutorialSteps.ts</done>
</task>

<task type="auto">
  <name>Task 2: Extend SaveData with tutorial persistence</name>
  <files>utils/storage.ts</files>
  <action>
Add to SaveData interface:
```
tutorialProgress: {
  completedSteps: string[];  // TutorialStepId values
}
```

Update `getDefaultSaveData()` to include `tutorialProgress: { completedSteps: [] }`.

Handle migration: In `loadSaveData()`, if loaded data lacks `tutorialProgress`, add the default. This follows the existing v2→v3 migration pattern — just add a fallback for missing fields. Do NOT bump the save version key (gooptris_save_v3 is fine, this is additive).

Update `useTutorial` hook to:
- Load `completedSteps` from SaveData on mount
- Call `saveGameData()` whenever a step is completed (persist immediately)

The hook should accept a `saveData: SaveData` param and a `setSaveData` callback (same pattern App.tsx uses for other save mutations), rather than loading/saving directly — this keeps it consistent with how upgrades and rank are saved.
  </action>
  <verify>
Run `npx tsc --noEmit` — no type errors.
Run `npm run test:run` — existing tests still pass (storage tests should not break since we're only adding a field with a default).
  </verify>
  <done>SaveData has tutorialProgress field, loadSaveData handles missing field gracefully, useTutorial persists completed steps through SaveData callback</done>
</task>

<task type="auto">
  <name>Task 3: Add tutorial event types to event bus</name>
  <files>core/events/GameEvents.ts</files>
  <action>
Add new GameEventType entries:

```
// Tutorial events
TUTORIAL_STEP_TRIGGERED = 'TUTORIAL_STEP_TRIGGERED',
TUTORIAL_STEP_COMPLETED = 'TUTORIAL_STEP_COMPLETED',
TUTORIAL_STEP_DISMISSED = 'TUTORIAL_STEP_DISMISSED',
```

These are emitted BY the useTutorial hook (not consumed by it — the hook consumes game events, but emits tutorial events so other systems can react to tutorial state changes). The TutorialOverlay (Plan 03) will subscribe to these.

Add payload types:
```
TutorialStepTriggeredPayload = { stepId: TutorialStepId; message: IntercomMessage }
TutorialStepCompletedPayload = { stepId: TutorialStepId }
TutorialStepDismissedPayload = { stepId: TutorialStepId }
```

Update useTutorial to emit these events when steps trigger, complete, or dismiss.

Do NOT add tutorial-specific game events like FIRST_ROTATE, FIRST_DROP etc. Those specific triggers will be added in Phase 33 when the actual training scenarios are built. For now, the ON_EVENT trigger type supports subscribing to ANY existing GameEventType (like PIECE_ROTATED, PIECE_DROPPED, GOOP_POPPED), which is sufficient.
  </action>
  <verify>
`npx tsc --noEmit` passes.
`npm run test:run` passes — no regressions.
  </verify>
  <done>Three new tutorial event types in GameEvents.ts, payload types defined, useTutorial emits events on state changes</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes with zero errors
- [ ] `npm run test:run` passes — all existing tests still green
- [ ] New files exist: types/tutorial.ts, hooks/useTutorial.ts, data/tutorialSteps.ts
- [ ] SaveData interface includes tutorialProgress
- [ ] GameEvents.ts includes 3 new tutorial event types
- [ ] useTutorial hook: loads from SaveData, manages state, emits events, persists completions
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors introduced
- No test regressions
- Tutorial state machine is functional (can trigger, complete, dismiss steps)
- State persists across page reloads via localStorage
</success_criteria>

<output>
After completion, create `.planning/phases/31-tutorial-infrastructure/31-01-SUMMARY.md`
</output>
