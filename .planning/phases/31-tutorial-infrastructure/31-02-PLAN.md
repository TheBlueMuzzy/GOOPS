---
phase: 31-tutorial-infrastructure
plan: 02
type: execute
---

<objective>
Build the intercom text rendering system — the static-corrupted text display where key tutorial terms come through clearly while surrounding words are garbled.

Purpose: This is the primary tutorial delivery mechanism. The employer speaks through a low-quality intercom/PA system. Static corrupts most words, but keywords come through clearly — naturally highlighting what the player needs to learn while establishing the grungy, uncaring corporate environment.
Output: IntercomText component (garble renderer), IntercomMessage component (full message display with typewriter effect).
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-tutorial-infrastructure/31-01-PLAN.md

# Key source files:
@types/tutorial.ts
@components/ConsoleView.tsx
@components/GameBoard.css

**Design decisions:**
- Intercom = employer's voice. Static-corrupted PA system.
- Key tutorial terms come through clearly, filler words are garbled
- Visual style: grungy low-tech (Lethal Company meets Uncle Chop's Rocket Shop), NOT scan-lines (performance issues)
- "Maintenance order" tooltip style
- 8 words max per instruction
- Non-blocking during gameplay

**Established patterns:**
- Tailwind CSS for all styling
- Plain CSS in GameBoard.css for animations (shake, glow, pulse)
- Color palette: bg-slate-950, text-slate-200, accents green-400/cyan-400/red-500
- Mobile-first, skip expensive filters on mobile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build IntercomText garble renderer</name>
  <files>components/IntercomText.tsx</files>
  <action>
Create `components/IntercomText.tsx` — a component that renders a text string where specified keywords appear clearly and all other words are replaced with static/garbled characters.

Props:
```
interface IntercomTextProps {
  fullText: string;        // The complete message
  keywords: string[];      // Words that render clearly (case-insensitive match)
  revealed?: boolean;      // If true, show all text clearly (for journal/replay)
  className?: string;
}
```

Garble algorithm:
1. Split fullText into words (preserve punctuation attached to words)
2. For each word, check if it matches any keyword (case-insensitive, strip punctuation for matching)
3. **Keyword words**: Render clearly in a brighter color (text-green-400) with slightly bolder weight
4. **Non-keyword words**: Replace each character with a random static character from a set like `░▒▓█▐▌╪╫╬─│┤├┬┴┼` (industrial/terminal feel). Use a seeded random based on word index so garble is stable (doesn't re-randomize on re-render). Keep same length as original word. Style with text-slate-600 (dim) and a monospace-ish feel.
5. Punctuation at end of keyword words should also render clearly.

The garble should feel like a bad radio transmission — you can tell words WERE there, but you can only make out the important ones.

Example:
- fullText: "Welcome to your new position, operator. Begin rotation training."
- keywords: ["rotation", "training"]
- Output: "▒░▓█▐▌▌ ▐░ ▓▒▌▐ ▌░▒ ▐▒▓█▐▌▒▓, ░▓▐▌▒▐▒▐. ▒▌▓░▌ **rotation** **training**."

Render as inline spans within a single paragraph. No line breaks unless the fullText contains them.

Do NOT add animation/typewriter here — that's IntercomMessage's job. This component is purely about the garble/clear text rendering.
  </action>
  <verify>`npx tsc --noEmit` passes</verify>
  <done>IntercomText component renders garbled text with clear keywords, stable garble on re-render, keywords highlighted in green-400</done>
</task>

<task type="auto">
  <name>Task 2: Build IntercomMessage display component</name>
  <files>components/IntercomMessage.tsx, components/IntercomMessage.css</files>
  <action>
Create `components/IntercomMessage.tsx` — the full intercom message display that wraps IntercomText with presentation, animation, and interaction.

Props:
```
interface IntercomMessageProps {
  message: IntercomMessage;     // { keywords, fullText } from tutorial types
  onDismiss: () => void;        // Called when player dismisses
  onComplete: () => void;       // Called when player acknowledges (marks step complete)
  position?: 'top' | 'center' | 'bottom';  // Where to show (default: top)
  className?: string;
}
```

Visual design — "Maintenance Order" style:
- Container: `bg-slate-900/95 border border-slate-700 rounded-sm` with a subtle inner glow/border
- Header bar: Small strip at top with "INTERCOM" or "TRANSMISSION" label in `text-xs text-slate-500 uppercase tracking-widest font-mono`
- Optional: A tiny blinking dot (red/orange) indicating "live transmission"
- Body: IntercomText component rendering the message
- Footer: Two small buttons — "✓" (acknowledge/complete, styled green) and "✗" (dismiss, styled muted). Keep them small and unobtrusive.
- Max width: ~280px (fits mobile without overwhelming)
- Position: fixed within the game's aspect-ratio container (not viewport-fixed), using absolute positioning

Typewriter reveal:
- On mount, progressively reveal characters (both garbled and clear) at ~30-50ms per character
- Use a simple counter state that increments via setInterval, slicing the rendered text
- When fully revealed, show the action buttons
- If `autoAdvanceMs` is set on the step, auto-complete after that delay (no buttons needed)

Interaction:
- Tapping anywhere on the message during typewriter → skip to fully revealed
- "✓" button → calls onComplete
- "✗" button → calls onDismiss
- pointer-events should be limited to the message box itself (not block the game behind it)

Add `components/IntercomMessage.css` for any animations that Tailwind can't handle (the blinking dot, typewriter cursor effect). Keep it minimal — prefer Tailwind inline.

Do NOT add sound effects — that's a future milestone.
  </action>
  <verify>`npx tsc --noEmit` passes</verify>
  <done>IntercomMessage component renders with typewriter effect, shows garbled text with clear keywords, has dismiss/acknowledge buttons, positioned within game container</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Intercom text rendering system with static-corrupted garble effect and typewriter reveal</what-built>
  <how-to-verify>
    1. Run: `npm run dev -- --host`
    2. Open browser to the dev server URL
    3. A test intercom message should appear (we'll add a temporary test trigger)
    4. Verify: Non-keyword words are garbled with industrial static characters (░▒▓█ etc.)
    5. Verify: Keyword words appear clearly in green
    6. Verify: Typewriter effect reveals characters progressively
    7. Verify: Tapping message skips to full reveal
    8. Verify: ✓ and ✗ buttons appear after reveal
    9. Verify: Message looks "grungy industrial" — NOT clean/modern
    10. Verify: Mobile-friendly sizing (not too wide, readable)
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes
- [ ] `npm run test:run` passes — no regressions
- [ ] IntercomText correctly garbles non-keyword words
- [ ] IntercomText highlights keywords clearly
- [ ] IntercomMessage has typewriter reveal
- [ ] Visual style matches grungy/industrial aesthetic
- [ ] Human verification passed
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- No test regressions
- Intercom text system visually matches the "grungy low-tech PA system" vision
- Human approved the visual result
</success_criteria>

<output>
After completion, create `.planning/phases/31-tutorial-infrastructure/31-02-SUMMARY.md`
</output>
