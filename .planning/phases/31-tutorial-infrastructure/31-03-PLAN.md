---
phase: 31-tutorial-infrastructure
plan: 03
type: execute
---

<objective>
Build the TutorialOverlay component and integrate the full tutorial system into Game.tsx, wiring together the state machine (Plan 01) and intercom display (Plan 02).

Purpose: Connect all tutorial infrastructure pieces so that tutorial steps can trigger during gameplay, display intercom messages, and persist completion state. This completes the tutorial delivery pipeline.
Output: Working TutorialOverlay in Game.tsx, end-to-end tutorial flow from trigger → display → interaction → persistence.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-tutorial-infrastructure/31-01-PLAN.md
@.planning/phases/31-tutorial-infrastructure/31-02-PLAN.md

# Key source files (read these before implementing):
@Game.tsx
@App.tsx
@hooks/useTutorial.ts
@components/IntercomMessage.tsx
@components/IntercomText.tsx
@types/tutorial.ts
@data/tutorialSteps.ts
@utils/storage.ts

**Design decisions:**
- TutorialOverlay sits at z-[90] in Game.tsx (above TransitionOverlay z-80, below nothing)
- Non-blocking during gameplay (pointer-events-none on overlay, pointer-events-auto on message box only)
- Max 1 tooltip/message visible at a time
- Intercom messages appear during gameplay, not between screens

**Component hierarchy target:**
Game.tsx
├─ GameBoard.tsx (z-0)
├─ ConsoleView.tsx (z-50)
├─ Controls.tsx (z-20)
├─ TransitionOverlay.tsx (z-80)
└─ TutorialOverlay.tsx (z-[90]) ← NEW
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build TutorialOverlay component</name>
  <files>components/TutorialOverlay.tsx</files>
  <action>
Create `components/TutorialOverlay.tsx` — the overlay shell that lives in Game.tsx and displays intercom messages when tutorial steps trigger.

Props:
```
interface TutorialOverlayProps {
  activeStep: TutorialStep | null;
  onComplete: () => void;    // Mark step completed
  onDismiss: () => void;     // Dismiss without completing
}
```

Implementation:
- Render as `absolute inset-0 z-[90] pointer-events-none` (covers game area but doesn't block input)
- When `activeStep` is not null, render an IntercomMessage with `pointer-events-auto` on the message itself
- Position the message based on `activeStep` context:
  - Default: top area (below the HUD, roughly top-20%)
  - Could be configurable per step in future, but default top for now
- Animate in with a brief fade (opacity transition, 200ms)
- Animate out on dismiss/complete (fade out 150ms, then clear)
- When no activeStep, render nothing (or an empty div with pointer-events-none)

Optional spotlight/highlight system (minimal for now):
- Add a `highlightArea?: { x: number; y: number; width: number; height: number }` to TutorialStep type
- If present, render a semi-transparent overlay with a cutout around the highlight area (using CSS clip-path or an SVG mask)
- For Phase 31, this is INFRASTRUCTURE only — don't wire it up to actual game elements yet. Just ensure the component supports it. The actual highlight coordinates will be provided by Phase 33's training scenarios.
- If no highlightArea, no dimming overlay — just the intercom message floating on top.
  </action>
  <verify>`npx tsc --noEmit` passes</verify>
  <done>TutorialOverlay renders IntercomMessage when activeStep exists, positioned correctly in z-stack, non-blocking pointer events, supports highlight area infrastructure</done>
</task>

<task type="auto">
  <name>Task 2: Integrate tutorial system into Game.tsx and App.tsx</name>
  <files>Game.tsx, App.tsx</files>
  <action>
Wire up the full tutorial pipeline:

**In App.tsx:**
- Pass `saveData` and `setSaveData` (or equivalent save callback) down to Game.tsx for tutorial persistence. Check how App.tsx currently passes save-related data — follow the same pattern (likely props).

**In Game.tsx:**
- Import and call `useTutorial(rank, isSessionActive, saveData, setSaveData)` (match the actual hook signature from Plan 01)
- Destructure: `{ activeStep, completeStep, dismissStep }`
- Add TutorialOverlay as the last child (highest z-index):
  ```jsx
  <TutorialOverlay
    activeStep={activeStep}
    onComplete={completeStep}
    onDismiss={dismissStep}
  />
  ```
- Place it AFTER TransitionOverlay in the JSX (renders on top)

**Test with placeholder steps:**
- The `data/tutorialSteps.ts` from Plan 01 should have 1-2 placeholder steps
- Verify the WELCOME step triggers when a rank-0 player starts a game
- If the current test save data has rank > 0, the step won't trigger (expected — it's rank-gated)
- For testing, you can temporarily add a step that triggers ON_GAME_START at any rank, or use the browser console to reset save data with `localStorage.removeItem('gooptris_save_v3')` and reload

**Integration checklist:**
- useTutorial hook called in Game.tsx
- TutorialOverlay rendered in Game.tsx
- SaveData flows from App.tsx → Game.tsx → useTutorial
- Tutorial step completion persists to localStorage
- No performance impact when tutorial is inactive (overlay renders nothing)
  </action>
  <verify>
`npx tsc --noEmit` passes.
`npm run test:run` passes — no regressions.
Dev server starts and runs without console errors.
  </verify>
  <done>Tutorial system fully wired: useTutorial in Game.tsx, TutorialOverlay rendered, save data flows through, placeholder step triggers on game start at rank 0</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete tutorial infrastructure: state machine → intercom display → overlay integration</what-built>
  <how-to-verify>
    1. Run: `npm run dev -- --host`
    2. Open browser, clear save data: open console → `localStorage.removeItem('gooptris_save_v3')` → reload
    3. You should be at rank 0 (fresh start)
    4. Start a game (pull periscope down)
    5. Verify: An intercom message appears near the top of the screen
    6. Verify: Message has garbled static text with clear keywords in green
    7. Verify: Typewriter effect reveals the message progressively
    8. Verify: You can still interact with the game BEHIND the message (non-blocking)
    9. Verify: Tapping the message skips typewriter to full reveal
    10. Verify: ✓ button dismisses and completes the step
    11. Reload the page, start another game — the message should NOT appear again (persisted as completed)
    12. Verify: No console errors, no performance issues
    13. Test on mobile viewport (use Chrome DevTools mobile emulation)
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes
- [ ] `npm run test:run` passes — all tests green
- [ ] `npm run build` succeeds
- [ ] Tutorial triggers on game start at rank 0
- [ ] Intercom message displays with garble + clear keywords
- [ ] Message is non-blocking (can play game behind it)
- [ ] Completing a step persists to localStorage
- [ ] No console errors or performance regressions
- [ ] Human verification passed
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors or test regressions
- Full tutorial pipeline works end-to-end: trigger → display → interact → persist
- Phase 31 complete — infrastructure ready for Phase 32 (Journal) and Phase 33 (Training Scenarios)
</success_criteria>

<output>
After completion, create `.planning/phases/31-tutorial-infrastructure/31-03-SUMMARY.md`:

# Phase 31 Plan 03: TutorialOverlay & Integration Summary

**[Substantive one-liner]**

## Accomplishments
- [Key outcomes]

## Files Created/Modified
- [File list]

## Decisions Made
- [Decisions and rationale]

## Issues Encountered
- [Problems and resolutions]

## Next Step
Phase 31 complete. Ready for Phase 32 (Journal System).
</output>
