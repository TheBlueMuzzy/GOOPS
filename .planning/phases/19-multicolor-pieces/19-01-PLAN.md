---
phase: 19-multicolor-pieces
plan: 01
type: execute
---

<objective>
Add per-cell color support to piece types and implement the split algorithm.

Purpose: Enable pieces to have multiple colors by adding `cellColors` array to PieceDefinition and creating a utility that finds balanced contiguous splits.
Output: Updated types.ts, new utils/pieceUtils.ts with tested split algorithm.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-multicolor-pieces/19-CONTEXT.md
@.planning/phases/19-multicolor-pieces/19-RESEARCH.md
@types.ts
@utils/gameLogic.ts

**From RESEARCH.md:**
- `cellColors?: string[]` parallel to `cells` array
- Algorithm: enumerate 2^n subsets (n=2-8 max), find most balanced where both groups are connected
- Use BFS for connectivity check, Set-based lookup for O(1) neighbor detection
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cellColors to PieceDefinition</name>
  <files>types.ts</files>
  <action>
Add optional `cellColors` field to `PieceDefinition` interface:

```typescript
export interface PieceDefinition {
  type: PieceType;
  cells: Coordinate[]; // Relative coordinates
  color: string;
  cellColors?: string[]; // Per-cell colors, parallel to cells array
}
```

This maintains backward compatibility - existing single-color pieces work without the field.
  </action>
  <verify>npm run test:run passes (existing tests should still work)</verify>
  <done>PieceDefinition has optional cellColors field, all existing tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Create split algorithm in pieceUtils.ts</name>
  <files>utils/pieceUtils.ts</files>
  <action>
Create new file `utils/pieceUtils.ts` with:

1. `coordKey(c: Coordinate): string` - Returns `${x},${y}` for Set lookups

2. `isConnected(cells: Coordinate[]): boolean` - BFS to check if all cells form one connected region (4-connectivity: up/down/left/right)

3. `findBestSplit(cells: Coordinate[]): [number[], number[]] | null` - Enumerate all subsets (mask 1 to 2^n-1), filter to valid bipartitions where both groups are connected, return most balanced (smallest |groupA.length - groupB.length|). Return indices, not coordinates.

4. `splitPiece(definition: PieceDefinition, colorA: string, colorB: string): PieceDefinition` - Apply split to piece, return new definition with cellColors array. If no valid split (shouldn't happen for n>=2), return single-color piece.

Key implementation notes from RESEARCH.md:
- Use Set for O(1) neighbor lookup
- Early exit on perfect 50/50 split (balance === 0)
- For n=2-8, max 256 iterations is fast enough
- Return indices to preserve cell order (rotation safety)
  </action>
  <verify>
Create tests in tests/pieceUtils.test.ts:
- isConnected: linear cells (I-piece), disconnected cells, single cell
- findBestSplit: I-piece (2+2), T-piece (3+1), O-piece (2+2)
- splitPiece: returns correct cellColors array

Run npm run test:run
  </verify>
  <done>
- pieceUtils.ts exists with all 4 functions
- Tests cover connectivity and split finding
- All tests pass
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run test:run` passes all tests (including new pieceUtils tests)
- [ ] types.ts has cellColors field
- [ ] pieceUtils.ts has isConnected, findBestSplit, splitPiece
- [ ] Unit tests verify algorithm correctness for I, T, O, S/Z pieces
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Split algorithm correctly handles all tetromino shapes
</success_criteria>

<output>
After completion, create `.planning/phases/19-multicolor-pieces/19-01-SUMMARY.md`
</output>
