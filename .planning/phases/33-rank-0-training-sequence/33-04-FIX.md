---
phase: 33-rank-0-training-sequence
plan: 04-FIX
type: fix
---

<objective>
Fix 9 UAT issues from plan 33-04.

Source: 33-04-ISSUES.md
Priority: 2 blocker, 5 major, 2 minor

The core problems: garble renderer is too aggressive (100% of non-keyword text is garbled), controls aren't gated per training step, game doesn't pause between steps, pieces are invisible while falling, and the UI (intercom window, highlight, HUD) needs repositioning.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

**Issues being fixed:**
@.planning/phases/33-rank-0-training-sequence/33-04-ISSUES.md

**Original plan for reference:**
@.planning/phases/33-rank-0-training-sequence/33-04-PLAN.md

**Prior phase context:**
@.planning/phases/33-rank-0-training-sequence/33-01-SUMMARY.md
@.planning/phases/33-rank-0-training-sequence/33-02-SUMMARY.md
@.planning/phases/33-rank-0-training-sequence/33-03-SUMMARY.md

**Key source files:**
@components/IntercomText.tsx
@components/TutorialOverlay.tsx
@components/TrainingHUD.tsx
@hooks/useTrainingFlow.ts
@data/trainingScenarios.ts
@data/tutorialSteps.ts
@core/GameEngine.ts
@Game.tsx
@components/IntercomMessageDisplay.tsx

**Established patterns:**
- Garble rendering is in IntercomText.tsx — seeded RNG replaces characters with block chars (░▒▓█▐▌╪╫╬─│┤├┬┴┼)
- Currently ALL non-keyword words are garbled (100%). Keywords matched case-insensitively, rendered green.
- TutorialOverlay at z-[90], pointer-events-none with pointer-events-auto on message box
- TrainingHUD at z-[85], 54px tall strip at top
- HIGHLIGHT_REGIONS maps string keys to viewport-percentage regions: { left, top, right, bottom }
- useTrainingFlow manages step advancement via event listeners and 4s fallback timer
- GameEngine.isTrainingMode gates complications/goals/cracks/heat in tick()
- Control inputs are handled in... (need to check where rotate/fast-drop inputs are processed)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix garble renderer — light corruption instead of heavy redaction (UAT-001, UAT-008)</name>
  <files>components/IntercomText.tsx, data/tutorialSteps.ts</files>
  <action>
**Two changes needed:**

**A) IntercomText.tsx — Change garble from "replace entire non-keyword words" to "corrupt individual characters within words":**

Current behavior: Every non-keyword word is completely replaced with block characters.
New behavior: Most text is readable. Only ~20-30% of characters in non-keyword words are garbled. Some entire words occasionally fully corrupted (maybe 1 in 8 non-keyword words), but most words have only 1-2 garbled characters or are fully clear.

Implementation approach:
1. For each non-keyword word, use the seeded RNG to decide corruption level:
   - 70% chance: word rendered fully clear (no garble)
   - 15% chance: 1-2 characters within the word are replaced with block chars (partial garble)
   - 15% chance: entire word garbled (current behavior, for thematic texture)
2. Garbled characters should still use the block character set but rendered in a slightly muted color (slate-500 instead of slate-600) so they blend with text rather than standing out as redactions
3. Keywords still rendered in green (#4ade80), font-semibold — no change to keyword handling
4. Keep the seeded RNG so garble is deterministic (same text renders same way each time)

The result should read like a corrupted radio transmission: "We░░ome aboard, **operator**. Standard **safety training** is m░ndatory before your first **shift**. ░░y attention."
NOT like a redacted document: "░▒▓█▐▌ ░▒▓█▐▌, **operator**. ░▒▓█▐▌ **safety training** ░▒ ░▒▓█▐▌ ░▒▓█▐▌ ░▒▓█▐▌ ░▒▓█▐▌ **shift**. ░▒ ░▒▓█▐▌."

**B) tutorialSteps.ts — Add control instructions to TRAINING_MESSAGES:**

Update the fullText for training messages that teach actions so they include HOW to perform the action:

- B2_FAST_FALL: Include "Swipe down to fast-drop" (or "Press W to fast-drop" — ideally detect touch vs keyboard but if that's complex, just say "Swipe down or press W to fast-drop")
- B3_PIECE_ROTATION: Include "Tap the rotation arrows" or "Press Q/E to rotate"
- D2_TANK_ROTATION: Include "Swipe left/right on the tank" or "Press A/D to rotate the tank"

Also add the relevant words to keywords arrays so the control instructions come through clearly. For example, add 'swipe', 'press W', 'tap', 'arrows' etc. to keywords.

Do NOT change messages that don't teach specific controls (A1, A2, C1, C3, etc.).
  </action>
  <verify>Run `npm run test:run` — all tests pass. Visually: intercom messages should now be mostly readable with light static corruption.</verify>
  <done>Garble renders ~70% of non-keyword words clearly, ~15% partially garbled, ~15% fully garbled. Messages that teach controls include HOW to perform the action. Keywords for control instructions are tagged.</done>
</task>

<task type="auto">
  <name>Task 2: Add progressive control gating during training (UAT-002)</name>
  <files>core/GameEngine.ts, hooks/useTrainingFlow.ts, types/training.ts</files>
  <action>
**Add control restriction system to training mode.**

Training should progressively enable controls as the player learns them:

**A) Add `allowedControls` to training step setup (types/training.ts):**

Add an optional field to `StepSetup`:
```
allowedControls?: {
  fastDrop?: boolean;
  rotate?: boolean;
  tankRotate?: boolean;
};
```

Defaults: if `allowedControls` is undefined, ALL controls are allowed (backward-compatible for non-training use). During training, each step should explicitly declare what's allowed.

**B) Update trainingScenarios.ts — set allowedControls per step:**

- A1_BRIEFING, A2_PERISCOPE: No controls needed (console view)
- B1_GOOP_INTRO: `{ fastDrop: false, rotate: false, tankRotate: false }` — watch only
- B2_FAST_FALL: `{ fastDrop: true, rotate: false, tankRotate: false }` — only fast-drop
- B3_PIECE_ROTATION: `{ fastDrop: true, rotate: true, tankRotate: false }` — add rotation
- C1_POP_INTRO through C3: `{ fastDrop: true, rotate: true, tankRotate: false }` — same as B3
- D1_CRACK_APPEARS: `{ fastDrop: true, rotate: true, tankRotate: false }` — no tank rotation yet
- D2_TANK_ROTATION: `{ fastDrop: true, rotate: true, tankRotate: true }` — all controls
- E1 through G3: `{ fastDrop: true, rotate: true, tankRotate: true }` — all controls

**C) Expose current allowed controls from useTrainingFlow:**

Return `allowedControls` from the hook (derived from `currentStep.setup.allowedControls`). When not in training, return undefined (all allowed).

**D) Wire control gating in GameEngine.ts:**

Add a property `trainingAllowedControls` to GameEngine. The useTrainingFlow hook sets this on step changes. In the input handling methods:
- `handleFastDrop()` or equivalent: check `this.trainingAllowedControls?.fastDrop !== false` before processing
- `handleRotation()` or equivalent: check `this.trainingAllowedControls?.rotate !== false`

**Important:** Find where input handling actually happens — it may be in useGameControls, GameBoard.tsx, or similar. Search for where fast-drop (INPUT_FAST_DROP event), rotation (PIECE_ROTATED event), and tank rotation (INPUT_DRAG / swipe) are processed. Gate at the input handler level, not the event level.

If input handling happens in React hooks/components rather than GameEngine, expose allowedControls as a ref and check it in the input handler.
  </action>
  <verify>Run `npm run test:run` — all tests pass. During B1, player should not be able to fast-drop or rotate. During B2, only fast-drop works. During B3+, rotation also works. D2+ enables tank rotation.</verify>
  <done>Controls are progressively gated per training step. B1=watch only, B2=fast-drop only, B3=+rotation, D2=+tank rotation. All controls available after D2.</done>
</task>

<task type="auto">
  <name>Task 3: Add pause between training steps (UAT-003)</name>
  <files>hooks/useTrainingFlow.ts</files>
  <action>
**Add a brief pause/freeze between training steps so the player can read the new message before gameplay resumes.**

Current behavior: When a step completes, the next step's message appears immediately while gameplay continues.
New behavior: When a step completes, gameplay freezes → next message fades in → player reads → player taps OK → gameplay resumes.

Implementation:
1. When `advanceStep` is called:
   - Set `engine.state.isPaused = true` immediately (freeze the game)
   - Add a small delay (300-500ms) before showing the next step's message (let the player see the result of their action)
   - Set `messageVisible = true` after the delay

2. The existing pause logic already unpauses when the player dismisses — this should continue to work. The key addition is: ALWAYS pause on step transition, regardless of the next step's `pauseGame` setting. The `pauseGame` field on the step should control whether the game STAYS paused after the player dismisses the message (for action steps where they need to read before acting) vs. unpauses after dismiss (for event-wait steps where gameplay needs to run).

3. For "tap" advance steps: dismiss = advance, so pause → message → tap → (if next step exists) pause again → next message. This creates a natural reading rhythm.

4. For "action"/"event" advance steps: pause → message → dismiss → unpause → player performs action → advance → pause → next message.

The 300-500ms delay should use a timeout, not a React state transition. Clear the timeout on unmount.
  </action>
  <verify>Run `npm run test:run` — all tests pass. Between each step, game should freeze briefly, show message, then wait for player acknowledgment before resuming.</verify>
  <done>Game pauses between every training step transition. Player has time to read each message before gameplay resumes. Natural pacing for the teaching sequence.</done>
</task>

<task type="auto">
  <name>Task 4: Fix invisible falling pieces during training (UAT-004)</name>
  <files>Game.tsx, components/GameBoard.tsx</files>
  <action>
**Diagnose and fix why falling pieces are invisible during training mode.**

The ghost (landing preview) shows but the actual falling piece is invisible until it locks.

Likely causes to investigate:
1. **Soft-body rendering pipeline not activating in training mode** — The physics-controlled falling piece rendering may have a condition that checks game state and skips during training. Check `useSoftBodyPhysics` or wherever falling piece rendering happens.
2. **Piece color not in the palette** — Training uses a specific palette (BLUE, YELLOW, GREEN, RED). If the piece spawns with a color not recognized by the rendering pipeline, it may not render.
3. **Training palette timing** — The palette might not be set when the first piece spawns, causing a render failure.
4. **The `view` being wrong** — If the game thinks it's still on the console view, the tank rendering (including pieces) won't show.

Investigation steps:
1. Search for where the active/falling piece is rendered (likely in GameBoard.tsx or a sub-component)
2. Check if there's a conditional like `if (!engine.isRunning)` or similar that prevents rendering during training
3. Check if the soft-body physics system has a condition that skips training mode
4. Look at whether the piece color from `generateNextGoop` with training palette matches what the rendering system expects

Fix whatever the root cause is. The falling piece must be visible during training, same as normal gameplay.
  </action>
  <verify>Run `npm run test:run` — all tests pass. Start training, enter tank — falling piece should be visible as it descends, not just the ghost.</verify>
  <done>Falling pieces are fully visible during training mode, rendering identically to normal gameplay.</done>
</task>

<task type="auto">
  <name>Task 5: Fix intercom window sizing and contextual positioning (UAT-005)</name>
  <files>components/IntercomMessageDisplay.tsx, components/TutorialOverlay.tsx</files>
  <action>
**Make the intercom message window wider and position it contextually based on the training step.**

Current behavior: Tall, narrow window at a fixed position.
New behavior: Wider window, positioned to guide the player's attention to the relevant UI area.

**A) Width:** Make the intercom window wider. It should be approximately 80-90% of the screen width on mobile (currently seems much narrower). Check the component's CSS and increase max-width or width.

**B) Contextual positioning:**
Add a `position` prop to the intercom display that can be:
- `'top'` — Near the top of the screen (below Operator Rank/XP bar, above Rank Select). For console-view steps (A1, A2).
- `'center'` — Vertically centered. For general teaching messages.
- `'bottom'` — Near the bottom. For when the focus should be on the top of the tank.

Set the position based on the training step:
- Console view steps (A1_BRIEFING, A2_PERISCOPE): `'top'` — between Operator Rank bar and Rank Select
- Tank view teaching steps (B1-B3, C1-C3, etc.): `'center'` — centered so it doesn't block too much of the tank
- Steps that reference bottom UI (pressure, etc.): `'top'` — so the bottom is visible

Wire the position through from useTrainingFlow → TutorialOverlay → IntercomMessageDisplay. Add a `messagePosition` field to StepSetup (optional, defaults to 'center').

**C) Keep it non-blocking:** The window should still have `pointer-events-auto` on itself but the overlay remains `pointer-events-none`.
  </action>
  <verify>Run `npm run test:run` — all tests pass. Intercom window should be wider and positioned contextually per step.</verify>
  <done>Intercom window is 80-90% width. Console steps position message near top. Tank steps position message center. All non-blocking.</done>
</task>

<task type="auto">
  <name>Task 6: Fix highlight cutout sizing and positioning (UAT-006)</name>
  <files>components/TutorialOverlay.tsx</files>
  <action>
**Fix the HIGHLIGHT_REGIONS to properly frame the periscope drag area.**

Current `periscope` region: `{ left: 20, top: 30, right: 80, bottom: 60 }` — this is way too large (60% of screen width, 30% of screen height).

The periscope drag handle is a specific element on the console screen. The highlight should tightly frame just that element.

**Approach:**
1. Look at the console layout to understand where the periscope drag area actually is. The periscope is likely a specific component or element on the console view. Check how the console is laid out (GameBoard.tsx or Console component).
2. Adjust the HIGHLIGHT_REGIONS `periscope` values to tightly frame just the periscope drag area. The region should be roughly centered horizontally and positioned where the periscope handle actually appears on screen.
3. Good approximate values might be something like `{ left: 35, top: 45, right: 65, bottom: 65 }` but this depends on the actual console layout. Look at the actual component positioning.

If exact positioning is hard to determine from code alone, use reasonable values that frame a small area (about 30% width, 20% height) centered on where the periscope handle appears. The user will refine during the next verification pass.

**Also:** Add a small amount of padding (2-3%) around the highlighted area so the cutout doesn't clip the element edges.
  </action>
  <verify>Run `npm run test:run` — all tests pass. During A2, the highlight cutout should frame roughly the periscope drag area, not half the screen.</verify>
  <done>Highlight cutout tightly frames the periscope drag area with reasonable padding. Not oversized.</done>
</task>

<task type="auto">
  <name>Task 7: Move training progress into intercom title bar (UAT-007)</name>
  <files>components/IntercomMessageDisplay.tsx, components/TrainingHUD.tsx, Game.tsx</files>
  <action>
**Instead of a separate TrainingHUD overlay at the top of the screen, integrate the training progress information into the intercom message title bar.**

Current behavior: TrainingHUD is a separate 54px overlay at z-85 that conflicts with console header text and may not render.
New behavior: The intercom message window itself shows training progress in its header.

**A) Add training progress props to IntercomMessageDisplay:**
Pass the following to IntercomMessageDisplay when in training mode:
- `phaseName`: string (e.g., "Phase B: Goop Basics")
- `stepProgress`: string (e.g., "Step 3 of 17")
- `phaseDots`: array of { phase: string, status: 'complete' | 'current' | 'upcoming' }

**B) Render progress in the intercom window header:**
Above the message text, add a compact header row:
- Left: Phase name (t-caption, slate-400)
- Right: "Step X of 17" (t-caption, slate-400)
- Below that row (or integrated): 7 small phase dots (6px circles). Complete=slate-400, Current=sky-400 with subtle pulse, Upcoming=slate-600 outline.

This replaces the TrainingHUD component. Keep the component file but stop rendering it in Game.tsx (or remove it entirely if cleaner).

**C) Only show training progress when in training mode.** When TutorialOverlay shows non-training tutorial steps (Phase 31 system), the intercom window should NOT show progress dots.
  </action>
  <verify>Run `npm run test:run` — all tests pass. Training progress (phase name, dots, step counter) should appear in the intercom message header, not as a separate overlay.</verify>
  <done>Training progress integrated into intercom message title bar. No separate HUD overlay needed. Phase dots, step counter, and phase name visible in message header during training.</done>
</task>

<task type="auto">
  <name>Task 8: Fix pressure meter during training (UAT-009)</name>
  <files>core/GameEngine.ts</files>
  <action>
**Allow pressure to rise during training so the player can see cause-and-effect.**

Current behavior: Training mode sets maxTime to 999999 to match shiftTime, resulting in PSI always showing ~0%. The `pressureRate` from step setup is defined in the data but never wired.

Fix:
1. In training mode, don't set maxTime = shiftTime. Instead, use a separate mechanism for the PSI display during training.
2. The PSI display uses `(elapsed / maxTime) * 100` — so in training, we need elapsed time to actually advance, OR we need to directly set a pressure value.
3. Simpler approach: Let the timer run normally during training but DON'T end the game when time expires. The `pressureRate` field in step setup can control how fast pressure rises. In training tick(), instead of skipping everything, let the time advance at `pressureRate` speed (where 1.0 = normal speed, 0 = frozen, 0.5 = half speed).
4. For steps with `pressureRate: 0` (default), pressure stays flat. For steps like E1 (`pressureRate: 0.3`), pressure rises slowly so the player can see it filling.

**Implementation:**
- In `startTraining()`: Set maxTime to the same value as normal gameplay (e.g., 75s) so the PSI bar has a meaningful scale
- In training `tick()`: Advance elapsed time by `deltaTime * currentPressureRate` instead of normal deltaTime
- Add a `trainingPressureRate` property to GameEngine, set by useTrainingFlow based on current step's `setup.pressureRate`
- Still skip complications, goals, crack growth, etc. — only the time/pressure should advance
- Do NOT end the game when elapsed >= maxTime in training mode — clamp pressure at 100% or reset it

Make sure the PSI HUD meter (likely in a HUD component) reads this value and displays correctly.
  </action>
  <verify>Run `npm run test:run` — all tests pass. During training steps with pressureRate > 0, the PSI meter should visibly rise. During pressureRate=0 steps, it stays flat.</verify>
  <done>Pressure meter responds to pressureRate per training step. PSI rises visibly during pressure-teaching steps (E1-E3). Flat during other steps. Game doesn't end when pressure reaches 100% in training.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Fixed all 9 UAT issues: lighter garble rendering, progressive control gating, pause between steps, visible falling pieces, wider/contextual intercom positioning, tighter highlight cutout, progress in intercom header, control instructions in messages, working pressure meter</what-built>
  <how-to-verify>
    1. Clear localStorage, reload to start fresh training at rank 0
    2. A1: Verify intercom message is READABLE (light garble, ~70% of words clear, keywords green)
    3. A1: Verify progress info in intercom header (phase name, dots, step counter)
    4. A1: Verify intercom window is wider (~80-90% screen width)
    5. A1: Verify message positioned near top (between Operator Rank bar and Rank Select)
    6. A2: Verify highlight cutout tightly frames periscope (not oversized)
    7. Enter tank → B1: Verify falling piece is VISIBLE (not just ghost)
    8. B1: Verify you CANNOT fast-drop or rotate (controls gated)
    9. B1: After piece lands, verify game PAUSES before next message
    10. B2: Verify fast-drop now works but rotation still disabled
    11. B2: Verify message explains HOW to fast-drop (mentions swipe/W key)
    12. B3: Verify rotation now works. Message explains HOW to rotate.
    13. D2: Verify tank rotation now enabled
    14. E1: Verify pressure meter starts rising (pressureRate active)
    15. Verify step-to-step transitions all pause briefly for reading
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All 9 UAT issues from 33-04-ISSUES.md addressed
- [ ] `npm run test:run` passes all existing tests
- [ ] No TypeScript errors
- [ ] Garble is light and readable
- [ ] Controls progressively gate
- [ ] Pause between steps works
- [ ] Falling pieces visible
- [ ] Intercom window wider and contextually positioned
- [ ] Highlight cutout properly sized
- [ ] Training progress in intercom header
- [ ] Control instructions in teaching messages
- [ ] Pressure meter responds to pressureRate
</verification>

<success_criteria>
- All 9 UAT issues from 33-04-ISSUES.md addressed
- Training flow plays smoothly with readable messages and progressive teaching
- Tests pass
- Ready for re-verification
</success_criteria>

<output>
After completion, create `.planning/phases/33-rank-0-training-sequence/33-04-FIX-SUMMARY.md`
</output>
