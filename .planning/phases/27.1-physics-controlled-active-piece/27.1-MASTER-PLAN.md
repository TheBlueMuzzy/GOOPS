# Phase 27.1 Master Plan: Physics-Controlled Active Piece

**Created:** 2026-02-05
**Status:** Ready for implementation
**Based on:** Comprehensive audit and design discussion

---

## Executive Summary

The soft-body physics system is 95% complete but not connected. The falling logic (`stepActivePieceFalling`) exists and is fully implemented but never called. This plan wires everything together so physics OWNS the falling motion and GameEngine READS the collision state.

---

## Part 1: Scaling Fixes

### 1.1 Parameters to Update in `types.ts` DEFAULT_PHYSICS

| Parameter | Current | Target | Rationale |
|-----------|---------|--------|-----------|
| attractionRadius | 20 | **12** | 20 × 0.6 = 12 |
| wallThickness | 8 | **4.8** | 8 × 0.6 = 4.8 |
| tendrilEndRadius | 10 | **6** | 10 × 0.6 = 6 |
| goopiness | 25 | **15** | 25 × 0.6 = 15 |
| dropletSize | 25 | **9** | Proto 15 × 0.6 = 9 (was scaled wrong) |
| dropletSpeed | 167 | **60** | Proto 100 × 0.6 = 60 (was scaled wrong) |

### 1.2 New Parameter to Add

```typescript
dropletGravity: 180,  // Proto 300 × 0.6 = 180 (separate from blob gravity)
```

### 1.3 Update in `useSoftBodyPhysics.ts`

```typescript
const PULSE_AMPLITUDE = 2.4;  // was 4, now 4 × 0.6 = 2.4
```

### 1.4 Slider Ranges to Verify

Ensure these sliders have adequate range for tuning:

| Slider | Current Range | Notes |
|--------|---------------|-------|
| attractionRadius | ? | Should include 12 and have room to tune |
| wallThickness | ? | Should include 4.8 |
| goopiness | ? | Should include 15 |
| dropletGravity | NEW | Add slider, range 50-300 |

---

## Part 2: Architecture Overview

### 2.1 Current Flow (Broken)

```
GameEngine owns activeGoop.y
    ↓
GameBoard reads activeGoop.y in preStepCallback
    ↓
GameBoard sets blob.targetY FROM activeGoop.y
    ↓
Physics wobbles toward target
    ↓
(Nothing syncs back)
(stepActivePieceFalling never called)
```

### 2.2 Target Flow (Correct)

```
GameEngine spawns piece at initial Y
    ↓
Physics creates blob, copies initial gridCells
    ↓
EACH FRAME:
    1. Get fallSpeed from GameEngine.getFallSpeed()
    2. Get grid and tankRotation from GameState
    3. Call stepActivePieceFalling(blob, dt, fallSpeed, grid, 16, 30, tankRotation)
    4. Physics updates blob.gridCells.y and blob.isColliding
    5. Return { gridY, isColliding } to Game.tsx
    6. Game.tsx calls engine.tickActivePiece(isColliding, gridY)
    7. GameEngine syncs activeGoop.y FROM physics (physics is source of truth)
    8. GameEngine manages lock timer based on isColliding
    ↓
When lock timer expires:
    GameEngine.lockActivePiece()
    Physics blob removed
    Locked blobs created for final grid cells
```

### 2.3 Key Principle

**Physics OWNS the Y position during falling. GameEngine READS it.**

---

## Part 3: Coordinate System

### 3.1 Visual vs Grid Coordinates

```
VISUAL/SCREEN coordinates:
- Used by physics blobs (blob.gridCells)
- Piece stays visually centered as tank rotates
- Range: x = 0 to TANK_VIEWPORT_WIDTH-1 (0-11), y = 0 to 15

GRID coordinates:
- Used by GameEngine (activeGoop.x)
- Piece position in cylindrical tank
- Range: x = 0 to TANK_WIDTH-1 (0-29), y = 0 to TANK_HEIGHT-1 (0-18)

Conversion:
  gridX = (visualX + tankRotation) % TANK_WIDTH
  visualX = (gridX - tankRotation + TANK_WIDTH) % TANK_WIDTH
```

### 3.2 Pixel Coordinates

```
SVG ViewBox: x=-180, y=0, width=360, height=480

Visual cell (visX, visY) → SVG pixel:
  pixelX = -180 + visX × 30
  pixelY = visY × 30

This is what PHYSICS_GRID_OFFSET represents:
  PHYSICS_GRID_OFFSET = { x: -180, y: 0 }
  PHYSICS_CELL_SIZE = 30
```

### 3.3 Tank Rotation Behavior

When player rotates tank (SpinTankCommand):
- Tank grid shifts left/right
- Falling piece stays at same VISUAL position
- Falling piece's GRID position changes (gridX = visualX + newRotation)
- Physics blob position UNCHANGED (it uses visual coordinates)
- Collision detection converts visual → grid using current tankRotation

---

## Part 4: Data Flow Details

### 4.1 Where Data Lives

| Data | Location | Owner |
|------|----------|-------|
| grid (TankCell[][]) | GameState | GameEngine |
| tankRotation | GameState | GameEngine |
| activeGoop | GameState | GameEngine |
| activeGoop.y (during falling) | blob.gridCells | Physics (source of truth) |
| isColliding | blob.isColliding | Physics |
| fallSpeed | GameEngine.getFallSpeed() | GameEngine |
| lock timer | GameEngine.lockStartTime | GameEngine |
| isFastDropping | GameEngine.isFastDropping | GameEngine |

### 4.2 What Gets Passed Where

```
Game.tsx
  │
  ├── Creates: useSoftBodyPhysics({ params })
  │
  ├── Creates: useGameEngine(..., handlePhysicsStep)
  │
  └── handlePhysicsStep(dt, engine):
        │
        ├── Get: fallSpeed = engine.getFallSpeed()
        ├── Get: grid = engine.state.grid
        ├── Get: tankRotation = engine.state.tankRotation
        │
        ├── Call: softBodyPhysics.step(dt, { grid, tankRotation, fallSpeed })
        │         └── Internally calls stepActivePieceFalling
        │
        ├── Get: { gridY, isColliding } = softBodyPhysics.getActivePieceState()
        │
        └── Call: engine.tickActivePiece(isColliding, gridY)
                  └── Updates activeGoop.y from gridY
                  └── Manages lock timer from isColliding
```

### 4.3 Physics Step Signature Change

Current:
```typescript
step(dt: number): void
```

New:
```typescript
step(dt: number, context?: {
  grid: TankCell[][],
  tankRotation: number,
  fallSpeed: number
}): void
```

---

## Part 5: Implementation Tasks

### Task 1: Update Scaling Parameters

**File:** `core/softBody/types.ts`

```typescript
export const DEFAULT_PHYSICS: PhysicsParams = {
  // Unchanged
  damping: 0.97,
  stiffness: 1,
  pressure: 3,
  iterations: 3,
  homeStiffness: 0.01,
  innerHomeStiffness: 0.1,
  returnSpeed: 0.5,
  viscosity: 2.5,
  gravity: 10,
  attractionStiffness: 0.005,
  attractionRestLength: 0,
  tendrilSkinniness: 0.7,
  dropletCount: 30,
  dropletLifetime: 3,

  // Scaled ×0.6
  attractionRadius: 12,
  wallThickness: 4.8,
  tendrilEndRadius: 6,
  goopiness: 15,
  dropletSize: 9,
  dropletSpeed: 60,

  // New
  dropletGravity: 180,
};
```

**File:** `hooks/useSoftBodyPhysics.ts`

```typescript
const PULSE_AMPLITUDE = 2.4;
```

**Verify:** TypeScript compiles, sliders still work.

---

### Task 2: Export stepActivePieceFalling

**File:** `core/softBody/physics.ts`

The function already exists (lines 655-725). Just add export:

```typescript
export function stepActivePieceFalling(
  blob: SoftBlob,
  dt: number,
  fallSpeed: number,
  grid: TankCell[][],
  visibleRows: number,
  tankWidth: number,
  tankRotation: number
): void {
  // ... existing implementation ...
}
```

**Verify:** TypeScript compiles.

---

### Task 3: Update useSoftBodyPhysics.step()

**File:** `hooks/useSoftBodyPhysics.ts`

Update step function to accept context and call falling logic:

```typescript
interface PhysicsStepContext {
  grid: TankCell[][];
  tankRotation: number;
  fallSpeed: number;
}

const step = useCallback(
  (dt: number, context?: PhysicsStepContext) => {
    if (!enabled) return;

    const blobs = blobsRef.current;
    const params = paramsRef.current;

    // Step falling blobs BEFORE core physics
    if (context) {
      for (const blob of blobs) {
        if (blob.isFalling && !blob.isLocked) {
          stepActivePieceFalling(
            blob,
            dt,
            context.fallSpeed,
            context.grid,
            TANK_VIEWPORT_HEIGHT,  // 16
            TANK_WIDTH,            // 30
            context.tankRotation
          );
        }
      }
    }

    // Core physics (wobble, springs, pressure)
    if (blobs.length > 0) {
      stepPhysics(blobs, dt, params, boundsRef.current);
      // ... rest of existing logic (fill, attraction, collisions) ...
    }

    // Droplets
    // ... existing droplet logic ...
  },
  [enabled]
);
```

**Verify:** TypeScript compiles.

---

### Task 4: Add getActivePieceState()

**File:** `hooks/useSoftBodyPhysics.ts`

Add method to return physics state for GameEngine:

```typescript
const getActivePieceState = useCallback((): { gridY: number; isColliding: boolean } | null => {
  const activeBlob = blobsRef.current.find(b => b.isFalling && !b.isLocked);
  if (!activeBlob) return null;

  // Calculate grid Y from blob's gridCells
  let sumY = 0;
  for (const cell of activeBlob.gridCells) {
    sumY += cell.y;
  }
  const avgY = sumY / activeBlob.gridCells.length;

  // Add BUFFER_HEIGHT to convert visual Y back to full grid Y
  const gridY = avgY + BUFFER_HEIGHT;

  return {
    gridY,
    isColliding: activeBlob.isColliding
  };
}, []);

// Add to return value
return {
  // ... existing ...
  getActivePieceState,
};
```

**Verify:** TypeScript compiles.

---

### Task 5: Update Game.tsx handlePhysicsStep

**File:** `Game.tsx`

Update the physics step callback to pass context and read state:

```typescript
const handlePhysicsStep = useCallback((dt: number, engine: GameEngine) => {
  // Build context for physics
  const context = {
    grid: engine.state.grid,
    tankRotation: engine.state.tankRotation,
    fallSpeed: engine.getFallSpeed()
  };

  // Run physics with context
  softBodyPhysics.step(dt, context);

  // Get physics output
  const physicsState = softBodyPhysics.getActivePieceState();

  // Update GameEngine from physics
  if (physicsState) {
    engine.tickActivePiece(physicsState.isColliding, physicsState.gridY);
  }
}, [softBodyPhysics]);
```

**Note:** `useGameEngine` hook needs to pass `engine` to the callback. Check if this is already the case or needs modification.

**Verify:** TypeScript compiles.

---

### Task 6: Update GameEngine.tickActivePiece

**File:** `core/GameEngine.ts`

Ensure tickActivePiece syncs Y from physics:

```typescript
tickActivePiece(physicsIsColliding: boolean, physicsGridY: number): void {
  if (!this.state.activeGoop) return;

  // Sync Y position from physics (physics is source of truth)
  this.state.activeGoop.y = physicsGridY;

  if (physicsIsColliding) {
    // Start lock timer when physics reports collision
    if (this.lockStartTime === null) {
      this.lockStartTime = Date.now();
    }

    const lockedTime = Date.now() - this.lockStartTime;
    const effectiveLockDelay = this.isFastDropping ? 50 : LOCK_DELAY_MS;

    if (lockedTime > effectiveLockDelay || this.lockResetCount >= 10) {
      this.lockActivePiece();
    }
  } else {
    // Not colliding - reset lock timer
    this.lockStartTime = null;
  }
}
```

**Remove:** Any existing Y position update logic in tick() that would compete with physics.

**Verify:** TypeScript compiles.

---

### Task 7: Remove GameBoard preStepCallback Y Sync

**File:** `components/GameBoard.tsx`

The current preStepCallback syncs activeGoop.y → blob.targetY. This is WRONG for physics-owned falling.

**Option A:** Remove preStepCallback entirely (physics owns position)

**Option B:** Keep callback but only sync X (for tank rotation), not Y

Recommended: **Option B** - The callback may still be useful for syncing X position and handling rotation.

```typescript
const syncFallingBlobPosition = () => {
  const goop = activeGoopRef.current;
  const rotation = tankRotationRef.current;

  if (!goop || goop.state !== GoopState.FALLING) return;

  const blobId = `active-${goop.spawnTimestamp}`;
  const blob = softBodyPhysics.getBlob(blobId);
  if (!blob) return;

  // Only sync X position (for visual centering)
  // Y is owned by physics via stepActivePieceFalling
  let visX = goop.screenX;  // Use screenX, not derived from grid

  const cells = goop.cells;
  let sumX = 0;
  for (const cell of cells) {
    sumX += visX + cell.x;
  }
  const centerX = sumX / cells.length;

  const targetX = PHYSICS_GRID_OFFSET.x + (centerX + 0.5) * PHYSICS_CELL_SIZE;

  // Only update X, preserve physics-controlled Y
  softBodyPhysics.updateBlobTargetX(blobId, targetX);
};
```

**Note:** May need to add `updateBlobTargetX()` method to hook, or use existing method carefully.

**Verify:** TypeScript compiles.

---

### Task 8: Handle Rotation Sync

When player rotates piece (RotateGoopCommand), the blob shape changes but Y should NOT reset.

**File:** `hooks/useSoftBodyPhysics.ts`

Add method to update blob shape without changing Y:

```typescript
const updateBlobShape = useCallback((blobId: string, newCells: Vec2[], visualX: number) => {
  const blob = blobsRef.current.find(b => b.id === blobId);
  if (!blob) return;

  // Preserve current Y values
  const currentBaseY = blob.gridCells.length > 0 ? blob.gridCells[0].y : 0;
  const currentOffsetY = blob.visualOffsetY;

  // Update gridCells with new shape, preserving Y
  blob.gridCells = newCells.map(cell => ({
    x: visualX + cell.x,
    y: currentBaseY + cell.y  // Relative Y from shape, base Y preserved
  }));

  // Preserve visualOffsetY
  blob.visualOffsetY = currentOffsetY;

  // Recalculate target position
  let sumX = 0, sumY = 0;
  for (const cell of blob.gridCells) {
    sumX += cell.x;
    sumY += cell.y;
  }
  const centroidX = sumX / blob.gridCells.length;
  const centroidY = sumY / blob.gridCells.length;

  blob.targetX = PHYSICS_GRID_OFFSET.x + (centroidX + 0.5) * PHYSICS_CELL_SIZE;
  blob.targetY = PHYSICS_GRID_OFFSET.y + (centroidY + 0.5) * PHYSICS_CELL_SIZE + blob.visualOffsetY;

  // Update vertex home positions for new shape
  // ... (recalculate home offsets from new centroid)
}, []);
```

**File:** `components/GameBoard.tsx`

Add effect to sync rotation to physics:

```typescript
useEffect(() => {
  if (!activeGoop || !softBodyPhysics) return;

  const blobId = `active-${activeGoop.spawnTimestamp}`;
  const blob = softBodyPhysics.getBlob(blobId);
  if (!blob) return;

  // Sync shape changes to physics (rotation)
  softBodyPhysics.updateBlobShape(blobId, activeGoop.cells, activeGoop.screenX);
}, [activeGoop?.rotation, activeGoop?.cells, softBodyPhysics]);
```

**Verify:** Rotation updates blob shape, Y position unchanged, no direction reversal.

---

### Task 9: Handle Piece Swap

When player swaps piece:
1. Old blob removed
2. New blob created at same visual position

The existing blob lifecycle (create on spawnTimestamp change, remove on lock) should handle this.

**Verify:** Test swap functionality - old blob gone, new blob appears, no duplicates.

---

## Part 6: Verification Checklist

### Automated
- [ ] `npx tsc --noEmit` passes
- [ ] `npm run test:run` passes

### Manual Testing

**Falling:**
- [ ] Piece falls smoothly (soft-body wobble)
- [ ] Fall speed matches expected (2 cells/sec at base)
- [ ] NO flickering
- [ ] Piece stops at floor
- [ ] Piece stops on top of other goop

**Fast Fall:**
- [ ] Hold S → piece falls 8x faster
- [ ] Still has wobble (maybe reduced due to speed)
- [ ] Lock delay reduced to 50ms

**Tank Rotation:**
- [ ] Piece stays visually centered when tank rotates
- [ ] Collision detection still works (can't rotate into goop)
- [ ] Piece slides over surface during lock delay

**Piece Rotation:**
- [ ] Rotate piece → blob shape updates
- [ ] Y position unchanged (no direction reversal)
- [ ] visualOffsetY preserved (no jumping)
- [ ] Wall kicks work

**Lock Timer:**
- [ ] 500ms delay before locking (normal)
- [ ] 50ms delay when fast-dropping
- [ ] Rotation resets timer
- [ ] Movement resets timer
- [ ] Max 10 resets before force-lock

**Swap:**
- [ ] Swap removes old blob
- [ ] New blob appears
- [ ] No duplicate blobs

**Visual Feel:**
- [ ] Blobs look like proto (wobble, size, filter)
- [ ] Droplets look like proto (size, speed, gravity)
- [ ] Fill animation looks right
- [ ] Ready-to-pop pulse visible

---

## Part 7: Bug Prevention

### Bug 1: Piece moves with tank rotation

**Prevention:** Physics blob uses VISUAL coordinates (screenX), not GRID coordinates (activeGoop.x). Verify blob creation and sync only use screenX.

### Bug 2: Falling too fast

**Prevention:**
- Verify `dt` is in seconds (0.016), not milliseconds (16)
- Verify `fallSpeed` is 60 px/sec base, not 480
- Verify `FAST_DROP_FACTOR` (8) only applied when `isFastDropping === true`
- Add debug logging: `console.log('fallSpeed:', fallSpeed, 'dt:', dt, 'isFastDropping:', engine.isFastDropping)`

### Bug 3: Falling past bottom

**Prevention:**
- Verify `visibleRows` parameter is 16 (TANK_VIEWPORT_HEIGHT), not 19 (TANK_HEIGHT)
- Verify collision check uses `nextVisY >= visibleRows`, not `>=` something else

### Bug 4: Reversing on rotation

**Prevention:**
- `updateBlobShape` preserves `visualOffsetY`
- `updateBlobShape` preserves base Y of gridCells
- Only relative cell positions (from rotation) change, not absolute Y

### Bug 5: Goops don't look like proto

**Prevention:** All Category 1 parameters scaled by 0.6.

---

## Part 8: Files Modified

| File | Changes |
|------|---------|
| `core/softBody/types.ts` | Update DEFAULT_PHYSICS, add dropletGravity |
| `core/softBody/physics.ts` | Add export to stepActivePieceFalling |
| `hooks/useSoftBodyPhysics.ts` | Update step() signature, add getActivePieceState(), add updateBlobShape(), update PULSE_AMPLITUDE |
| `Game.tsx` | Update handlePhysicsStep to pass context and read state |
| `core/GameEngine.ts` | Update tickActivePiece to sync Y from physics |
| `components/GameBoard.tsx` | Update/remove preStepCallback, add rotation sync effect |

---

## Part 9: Decisions Made

| Decision | Value | Rationale |
|----------|-------|-----------|
| Scaling approach | Option A (scale params to 30px) | Allows slider tuning from scaled starting point |
| Fall speed | Keep live (2 cells/sec) | User decision |
| Fast fall | Keep live (8x multiplier) | User decision |
| Coordinate system | Keep live (centered viewBox) | User decision |
| FILL_RATE | Keep live (0.5) | User decision |
| Droplet gravity | Separate slider (start at 180) | Allows tuning |

---

## Part 10: Open Items for Tuning

After implementation, user will tune these via sliders:

1. **attractionRadius** - starting at 12, may need adjustment
2. **wallThickness** - starting at 4.8, may need adjustment
3. **goopiness** - starting at 15, may need adjustment
4. **dropletGravity** - starting at 180, may need adjustment
5. **Spring constants** - may need adjustment if dynamics feel off

---

## Appendix: Constants Reference

```typescript
// Grid dimensions
TANK_WIDTH = 30              // Cylindrical width in cells
TANK_HEIGHT = 19             // Full height (16 visible + 3 buffer)
TANK_VIEWPORT_WIDTH = 12     // Visible columns
TANK_VIEWPORT_HEIGHT = 16    // Visible rows
BUFFER_HEIGHT = 3            // Rows above viewport

// Physics space
PHYSICS_CELL_SIZE = 30       // Pixels per cell
PHYSICS_GRID_OFFSET = { x: -180, y: 0 }  // SVG origin offset

// Fall speeds
baseCellsPerSec = 2          // Normal fall (60 px/sec)
FAST_DROP_FACTOR = 8         // Fast fall multiplier (480 px/sec)
LOCK_DELAY_MS = 500          // Normal lock delay
fastDropLockDelay = 50       // Fast drop lock delay

// Lock limits
maxLockResets = 10           // Force lock after this many resets
```
