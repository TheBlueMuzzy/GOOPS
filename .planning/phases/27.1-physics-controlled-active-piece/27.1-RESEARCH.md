# Phase 27.1: Physics-Controlled Active Piece - Research

**Researched:** 2026-02-05
**Domain:** Verlet soft-body physics integration with falling-block puzzle game mechanics
**Confidence:** HIGH

<research_summary>
## Summary

Researched how to transfer falling piece motion from GameEngine to SoftBodyPhysics. The current architecture has GameEngine update grid position, then syncs blob target position, causing a timing mismatch that produces flickering.

The proven solution is the **Proto-9 pattern**: physics owns the falling motion directly via `visualOffsetY`. Instead of syncing blob position TO game state, the physics simulation IS the source of truth for visual position. Grid state only commits when the piece locks.

**Primary recommendation:** Port Proto-9's `visualOffsetY` pattern to active pieces. Physics drives smooth falling with collision detection against locked goop. GameEngine becomes the consumer of physics state (for lock detection, scoring) rather than the driver.

</research_summary>

<standard_stack>
## Standard Stack

### Core (Already In Project)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Verlet physics | Custom | Soft-body simulation | Already ported from prototypes |
| useSoftBodyPhysics | Custom | React hook interface | Already integrated |
| blobFactory | Custom | Grid-to-pixel conversion | Already handles coordinates |

### Architecture Pattern
| Pattern | Purpose | Status |
|---------|---------|--------|
| visualOffsetY | Smooth sub-cell falling motion | Proven in Proto-9 |
| Grid collision | Check cells below for obstacles | Proven in Proto-9 |
| Deferred lock | Queue lock action to end-of-frame | Proven in Proto-9 |
| Two-tier authority | Grid = truth, Physics = visual | Industry standard |

### No External Dependencies Needed
This phase uses existing code. No npm packages required.

</standard_stack>

<architecture_patterns>
## Architecture Patterns

### Recommended: Two-Layer Architecture

```
┌─────────────────────────────────────────────────┐
│           AUTHORITATIVE LAYER                    │
│  GameEngine grid state (discrete cells)          │
│  - Determines collisions, clears, scoring        │
│  - Updated when piece LOCKS (not during fall)    │
└─────────────────────────────────────────────────┘
                      ▲
                      │ Lock event (once per piece)
                      │
┌─────────────────────────────────────────────────┐
│           VISUAL/PHYSICS LAYER                   │
│  SoftBodyPhysics (continuous motion)             │
│  - Owns falling motion (visualOffsetY)           │
│  - Drives smooth animation every frame           │
│  - Detects collision via grid read-only lookup   │
└─────────────────────────────────────────────────┘
```

### Pattern 1: visualOffsetY Falling
**What:** Sub-cell offset that accumulates during falling, resets on grid cell transition
**When to use:** Any smooth falling motion that needs to track grid position
**Example:**
```typescript
// From Proto-9 (lines 1598-1609)
const fallAmount = fallSpeed * dt;
fallingBlob.visualOffsetY += fallAmount;

// Move grid cells when offset exceeds cell size
while (fallingBlob.visualOffsetY >= CELL_SIZE) {
  for (const cell of fallingBlob.gridCells) {
    cell.y += 1;
  }
  fallingBlob.visualOffsetY -= CELL_SIZE;
}

// Update physics target (this drives visual position)
const gridCentroid = getGridCentroid(fallingBlob.gridCells);
fallingBlob.targetY = gridCentroid.y + fallingBlob.visualOffsetY;
```

### Pattern 2: Grid-Based Collision Detection
**What:** Check if cells below are occupied by different blob or floor
**When to use:** Determining when piece can't fall further
**Example:**
```typescript
// From Proto-9 (lines 1617-1629)
let canFallMore = true;
for (const cell of fallingBlob.gridCells) {
  const nextY = cell.y + 1;
  if (nextY >= GRID_ROWS) {
    canFallMore = false;
    break;
  }
  const targetCell = grid[nextY]?.[cell.x];
  if (targetCell && targetCell.blobId !== fallingBlob.id) {
    canFallMore = false;
    break;
  }
}
```

### Pattern 3: Deferred Lock Action
**What:** Queue lock for end-of-frame rather than mutating mid-loop
**When to use:** When lock causes state changes that affect other operations
**Example:**
```typescript
// Flag for lock (Proto-9 line 1633)
if (!canFallMore && fallingBlob.visualOffsetY < 0.1) {
  needsLockRef.current = true;
}

// At end of physics step (Proto-9 line 1715-1718)
if (needsLockRef.current) {
  lockActivePiece();
  needsLockRef.current = false;
}
```

### Anti-Patterns to Avoid
- **Double-update loop:** GameEngine updates position → Physics reads it → Rendering sees stale data. This is the CURRENT bug.
- **Physics follows game state:** Creates timing mismatch. Physics should LEAD, game state should FOLLOW.
- **Timer-only lock detection:** Proto-9 uses collision + position threshold. More responsive than timers.

</architecture_patterns>

<dont_hand_roll>
## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Smooth falling | Custom lerp/interpolation | visualOffsetY + Verlet | Proto-9 pattern is proven, handles wobble naturally |
| Collision detection | Raycasting or physics queries | Grid cell lookup | Grid is source of truth, O(1) lookup |
| Lock timing | Complex state machines | canFallMore + visualOffsetY threshold | Simple and responsive |
| Frame timing | Variable dt physics | Fixed timestep accumulator | Industry standard, prevents instability |

**Key insight:** Proto-9 already solved all these problems. The entire falling system can be ported with minimal modification. Don't reinvent—extract and integrate.

</dont_hand_roll>

<common_pitfalls>
## Common Pitfalls

### Pitfall 1: Double-Update Timing Mismatch (CURRENT BUG)
**What goes wrong:** Flickering between game state position and physics position
**Why it happens:** GameEngine updates grid position, sync updates blob target, physics updates blob position. Three sources of truth → timing gaps.
**How to avoid:** Physics OWNS falling motion. GameEngine only reads position at lock time.
**Warning signs:** Flickering, position jumps, visual desync from expected position

### Pitfall 2: Spiral of Death
**What goes wrong:** Physics takes longer than real-time, frame budget explodes
**Why it happens:** Accumulator grows unboundedly when physics step exceeds frame time
**How to avoid:** Cap maximum physics steps per frame (e.g., max 4 steps)
**Warning signs:** Sudden slowdowns, physics "catching up" visibly, dropped frames

### Pitfall 3: Lock Happening Too Early
**What goes wrong:** Piece locks before visually reaching rest position
**Why it happens:** Collision detected when visualOffsetY still has sub-cell offset
**How to avoid:** Require `visualOffsetY < 0.1` threshold before lock (Proto-9 pattern)
**Warning signs:** Pieces appearing to "pop" into place, gap between piece and stack

### Pitfall 4: Grace Period Feel
**What goes wrong:** Game feels unforgiving—no time to adjust after landing
**Why it happens:** Proto-9 has NO grace period (immediate lock)
**How to avoid:** Keep GameEngine's existing lock delay (500ms), triggered when physics reports collision
**Warning signs:** User complaints about not being able to adjust after landing

### Pitfall 5: Fast-Fall Breaking Physics
**What goes wrong:** Fast-fall causes tunneling or position jumps
**Why it happens:** Large dt or velocity injection skips collision checks
**How to avoid:** Multiply gravity (not inject velocity), cap maximum fall per frame
**Warning signs:** Pieces passing through obstacles, ending up below floor

</common_pitfalls>

<code_examples>
## Code Examples

### Active Piece Physics Step (Proto-9 Pattern)
```typescript
// Source: Proto-9 lines 1598-1635, adapted for Goops
function stepActivePieceFalling(blob: SoftBlob, dt: number, grid: Grid) {
  // Calculate fall amount
  const baseSpeed = isFastDropping ? FALL_SPEED * FAST_DROP_FACTOR : FALL_SPEED;
  const fallAmount = baseSpeed * dt;

  // Check if can fall more BEFORE moving
  let canFallMore = true;
  for (const cell of blob.gridCells) {
    const nextY = cell.y + 1;
    if (nextY >= GRID_ROWS || (grid[nextY]?.[cell.x] && grid[nextY][cell.x].blobId !== blob.id)) {
      canFallMore = false;
      break;
    }
  }

  if (canFallMore) {
    // Accumulate visual offset
    blob.visualOffsetY += fallAmount;

    // Move grid cells when offset exceeds cell size
    while (blob.visualOffsetY >= CELL_SIZE) {
      for (const cell of blob.gridCells) {
        cell.y += 1;
      }
      blob.visualOffsetY -= CELL_SIZE;
    }
  }

  // Update physics target position
  const gridCentroid = getGridCentroid(blob.gridCells);
  blob.targetY = gridCentroid.y + blob.visualOffsetY;

  // Landing check
  if (!canFallMore && blob.visualOffsetY < 0.1) {
    return { shouldLock: true };
  }

  return { shouldLock: false };
}
```

### Integration Point: GameEngine Lock Handler
```typescript
// Source: Goops current pattern, adapted for physics-driven falling
// GameEngine stops driving position, starts listening for lock signal

function tickActivePiece(dt: number) {
  const activePieceBlob = softBodyPhysics.getActivePieceBlob();
  if (!activePieceBlob) return;

  // Physics drives falling - just check for lock signal
  if (activePieceBlob.shouldLock && !this.lockTimerStarted) {
    this.startLockTimer();  // Existing grace period logic
  }

  // When lock timer expires, commit physics position to game state
  if (this.lockTimerExpired) {
    const finalCells = activePieceBlob.gridCells;
    this.commitPieceToGrid(finalCells);  // Existing lock logic
    softBodyPhysics.lockActivePiece();   // Tell physics to convert to locked blob
  }
}
```

### Fast-Fall: Gravity Boost (Not Velocity Injection)
```typescript
// Source: Industry pattern, NOT Proto-9 (which has no fast-fall button)
// Fast-fall multiplies gravity, doesn't inject velocity

const FALL_SPEED = 200;        // pixels/second (normal)
const FAST_DROP_FACTOR = 8;    // 8x multiplier (matches existing Goops behavior)

const effectiveSpeed = isFastDropping
  ? FALL_SPEED * FAST_DROP_FACTOR
  : FALL_SPEED;
```

</code_examples>

<sota_updates>
## State of the Art (2024-2026)

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Game state drives visuals | Physics drives visuals, game state follows | Always best practice | Eliminates timing mismatch |
| Timer-only lock delay | Collision + position threshold + timer | Modern Tetris variants | More responsive feel |
| Variable timestep physics | Fixed timestep with accumulator | Always best practice | Stable simulation |

**Patterns from modern falling-block games:**
- **Tetris Effect (2018+):** Visual layer interpolates between authoritative states
- **Puyo Puyo Tetris 2:** Lock delay with move reset (limited resets)
- **Not Tetris 2:** Physics owns falling, grid commits when stable (>80% cell coverage rule)

**Key insight from research:** The industry standard is "grid leads, physics follows" for LOCKED pieces. But for FALLING pieces, "physics leads, grid follows" (commit on lock). Our current bug is that we have it backwards during falling.

</sota_updates>

<open_questions>
## Open Questions

1. **Grace period implementation**
   - What we know: Proto-9 has no grace period (immediate lock). Current Goops has 500ms.
   - What's unclear: Should physics report "shouldLock" and GameEngine manages timer? Or should physics own the timer?
   - Recommendation: Physics reports collision state, GameEngine owns grace period timer (preserves existing feel)

2. **Rotation during fall**
   - What we know: Proto-9 does NOT rotate during fall (rotation = 0 always). Current Goops rotates via Q/E.
   - What's unclear: Should rotation affect physics blob shape? Or just visual?
   - Recommendation: Rotation updates `blob.gridCells` (offsets), physics recomputes `targetX/Y` from new centroid. No dynamic tumble physics needed.

3. **Piece swap interaction**
   - What we know: Piece swap currently happens at lock decision time.
   - What's unclear: Does swapping need to update physics blob, or just wait for new piece spawn?
   - Recommendation: Swap removes current blob, spawns new blob for swapped piece (clean handoff)

4. **Fast-fall feel**
   - What we know: Goops uses 8x multiplier. Proto-9 has no fast-fall button.
   - What's unclear: Does 8x feel right with physics wobble? Might need tuning.
   - Recommendation: Start with 8x, tune if wobble feels wrong at high speed

</open_questions>

<sources>
## Sources

### Primary (HIGH confidence)
- `prototypes/SoftBodyProto9.tsx` — Complete falling system implementation (lines 1598-1700)
- `core/softBody/physics.ts` — Verlet engine implementation
- `core/GameEngine.ts` — Current falling logic (lines 1186-1265)

### Secondary (MEDIUM confidence)
- Tetris Wiki (Lock delay, Drop mechanics) — Industry patterns verified
- Gaffer on Games (Fix Your Timestep) — Fixed timestep accumulator pattern
- Game Programming Patterns (Game Loop) — Two-layer architecture

### Tertiary (LOW confidence - needs validation)
- Not Tetris 2 approach (>80% coverage rule) — Different game, may not apply
- Cowboy Programming blob physics — General soft-body, not puzzle-specific

</sources>

<metadata>
## Metadata

**Research scope:**
- Core technology: Verlet soft-body physics (already in project)
- Ecosystem: Proto-9 patterns, industry standards for falling-block games
- Patterns: visualOffsetY, grid collision, deferred lock, two-layer architecture
- Pitfalls: Double-update timing, lock threshold, fast-fall tunneling

**Confidence breakdown:**
- Standard stack: HIGH - Already implemented in project
- Architecture: HIGH - Proto-9 is working code, industry patterns verified
- Pitfalls: HIGH - Current bug is documented, Proto-9 avoids it
- Code examples: HIGH - Directly from Proto-9 source

**Research date:** 2026-02-05
**Valid until:** 2026-03-05 (30 days - internal code, stable patterns)

</metadata>

---

*Phase: 27.1-physics-controlled-active-piece*
*Research completed: 2026-02-05*
*Ready for planning: yes*
