---
phase: 25-physics-foundation
plan: 01
type: execute
---

<objective>
Create soft-body physics types and port Verlet engine core from Proto-9.

Purpose: Establish the foundational physics system that all soft-body rendering depends on.
Output: `core/softBody/types.ts` with interfaces, `core/softBody/physics.ts` with Verlet solver.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Source to port from:**
@prototypes/SoftBodyProto9.tsx (lines 1-150 for types, 750-950 for physics)

**Tuned physics parameters from prototypes:**
| Parameter | Value | Notes |
|-----------|-------|-------|
| Damping | 0.97 | High, preserves momentum |
| Stiffness | 1 | Very low, loose springs |
| Pressure | 5 | Strong volume maintenance |
| Home Stiffness | 0.3 | Shape retention |
| Return Speed | 0.5 | Moderate |
| Viscosity | 2.5 | Honey-like for locked blobs |

**Key insight:** Physics runs in flat pixel space. Cylindrical projection is rendering-only (Phase 26).
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create soft-body type definitions</name>
  <files>src/core/softBody/types.ts</files>
  <action>
Extract and create type definitions from Proto-9:

```typescript
// Vector math
export interface Vec2 { x: number; y: number; }

// Physics vertex with Verlet state
export interface Vertex {
  pos: Vec2;           // Current position (pixels)
  oldPos: Vec2;        // Previous position (for Verlet integration)
  homeOffset: Vec2;    // Offset from blob center (rest shape)
  mass: number;        // Usually 1.0
  attractionRadius: number; // Per-vertex attraction multiplier (0.3-1.5)
}

// Spring constraint between vertices
export interface Spring {
  a: number;           // Index of first vertex
  b: number;           // Index of second vertex
  restLength: number;  // Target distance
}

// Attraction spring between blobs (for merge tendrils)
export interface AttractionSpring {
  blobA: number;       // Index of first blob
  blobB: number;       // Index of second blob
  vertexA: number;     // Vertex index in blobA
  vertexB: number;     // Vertex index in blobB
  restLength: number;
}

// Complete blob state
export interface SoftBlob {
  id: string;
  color: string;
  vertices: Vertex[];
  innerVertices: Vertex[];  // Stable core for complex merges
  ringsprings: Spring[];    // Perimeter edge springs
  crossSprings: Spring[];   // Structural support springs
  restArea: number;         // Target area (Shoelace formula)
  gridCells: Vec2[];        // Which grid cells this blob occupies
  isLocked: boolean;        // Locked = viscous, Falling = snappy
  fillAmount: number;       // 0-1 for fill animation
  rotation: number;         // Current rotation angle
  targetX: number;          // Target center X (pixels)
  targetY: number;          // Target center Y (pixels)
  visualOffsetY: number;    // Smooth falling offset
}

// Tunable physics parameters
export interface PhysicsParams {
  damping: number;          // Energy loss per frame (0.97 = high)
  stiffness: number;        // Spring correction strength (1 = very low)
  pressure: number;         // Volume maintenance force (5 = strong)
  iterations: number;       // Constraint solver iterations (3-5)
  homeStiffness: number;    // Shape retention strength (0.3)
  returnSpeed: number;      // Home position return rate (0.5)
  viscosity: number;        // Locked blob dampening (2.5)
  gravity: number;          // Downward acceleration (10)
}

// Default parameters (tuned from Proto-9)
export const DEFAULT_PHYSICS: PhysicsParams = {
  damping: 0.97,
  stiffness: 1,
  pressure: 5,
  iterations: 3,
  homeStiffness: 0.3,
  returnSpeed: 0.5,
  viscosity: 2.5,
  gravity: 10,
};
```

Also add vector math utilities:
- `vecAdd(a, b)`, `vecSub(a, b)`, `vecScale(v, s)`, `vecLength(v)`, `vecNormalize(v)`
- `vecDot(a, b)`, `vecDistance(a, b)`
- `rotatePoint(point, angle)` for home offset rotation
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>All soft-body types exported, vector utilities available, DEFAULT_PHYSICS constant defined</done>
</task>

<task type="auto">
  <name>Task 2: Port Verlet physics engine core</name>
  <files>src/core/softBody/physics.ts</files>
  <action>
Port the physics solver from Proto-9 (lines 750-950). Create pure functions that operate on blob arrays:

**1. Integration step (Verlet):**
```typescript
export function integrate(blobs: SoftBlob[], dt: number, params: PhysicsParams): void {
  // Cap dt at 33ms for stability
  const cappedDt = Math.min(dt, 0.033);

  for (const blob of blobs) {
    const effectiveDamping = blob.isLocked
      ? params.damping / params.viscosity  // Slower for locked blobs
      : params.damping;

    for (const v of blob.vertices) {
      const vx = (v.pos.x - v.oldPos.x) * effectiveDamping;
      const vy = (v.pos.y - v.oldPos.y) * effectiveDamping;

      v.oldPos.x = v.pos.x;
      v.oldPos.y = v.pos.y;

      v.pos.x += vx;
      v.pos.y += vy + params.gravity * cappedDt * cappedDt;
    }
    // Same for innerVertices
  }
}
```

**2. Home force (shape retention):**
```typescript
export function applyHomeForce(blobs: SoftBlob[], params: PhysicsParams): void {
  for (const blob of blobs) {
    for (const v of blob.vertices) {
      const rotatedHome = rotatePoint(v.homeOffset, blob.rotation);
      const targetX = blob.targetX + rotatedHome.x;
      const targetY = blob.targetY + rotatedHome.y;

      v.pos.x += (targetX - v.pos.x) * params.homeStiffness * params.returnSpeed;
      v.pos.y += (targetY - v.pos.y) * params.homeStiffness * params.returnSpeed;
    }
  }
}
```

**3. Constraint solving (springs):**
```typescript
export function solveConstraints(blobs: SoftBlob[], params: PhysicsParams): void {
  for (let iter = 0; iter < params.iterations; iter++) {
    for (const blob of blobs) {
      // Ring springs (perimeter) - stiffness * 0.01
      for (const spring of blob.ringsprings) {
        solveSpring(blob.vertices, spring, params.stiffness * 0.01);
      }
      // Cross springs (structural) - stiffness * 0.005
      for (const spring of blob.crossSprings) {
        solveSpring(blob.vertices, spring, params.stiffness * 0.005);
      }
    }
  }
}

function solveSpring(vertices: Vertex[], spring: Spring, strength: number): void {
  const a = vertices[spring.a];
  const b = vertices[spring.b];
  const dx = b.pos.x - a.pos.x;
  const dy = b.pos.y - a.pos.y;
  const dist = Math.sqrt(dx * dx + dy * dy) || 0.001;
  const error = dist - spring.restLength;
  const correction = (error / dist) * strength * 0.5;

  a.pos.x += dx * correction;
  a.pos.y += dy * correction;
  b.pos.x -= dx * correction;
  b.pos.y -= dy * correction;
}
```

**4. Pressure (radial, for locked blobs only):**
```typescript
export function applyPressure(blobs: SoftBlob[], params: PhysicsParams): void {
  for (const blob of blobs) {
    if (!blob.isLocked) continue;  // Only locked blobs get pressure

    // Calculate current centroid
    let cx = 0, cy = 0;
    for (const v of blob.vertices) {
      cx += v.pos.x;
      cy += v.pos.y;
    }
    cx /= blob.vertices.length;
    cy /= blob.vertices.length;

    // Calculate rest distance (average home offset length)
    const restDist = blob.vertices.reduce((sum, v) =>
      sum + vecLength(v.homeOffset), 0) / blob.vertices.length;

    // Apply radial pressure
    for (const v of blob.vertices) {
      const dx = v.pos.x - cx;
      const dy = v.pos.y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy) || 0.001;
      const error = restDist - dist;
      const force = error * params.pressure * 0.002;

      v.pos.x += (dx / dist) * force;
      v.pos.y += (dy / dist) * force;
    }
  }
}
```

**5. Boundary constraints:**
```typescript
export function applyBoundaryConstraints(
  blobs: SoftBlob[],
  bounds: { minX: number; maxX: number; minY: number; maxY: number }
): void {
  for (const blob of blobs) {
    for (const v of blob.vertices) {
      if (v.pos.x < bounds.minX) v.pos.x = bounds.minX;
      if (v.pos.x > bounds.maxX) v.pos.x = bounds.maxX;
      if (v.pos.y < bounds.minY) v.pos.y = bounds.minY;
      if (v.pos.y > bounds.maxY) v.pos.y = bounds.maxY;
    }
  }
}
```

**6. Main physics step:**
```typescript
export function stepPhysics(
  blobs: SoftBlob[],
  dt: number,
  params: PhysicsParams,
  bounds: { minX: number; maxX: number; minY: number; maxY: number }
): void {
  integrate(blobs, dt, params);
  applyHomeForce(blobs, params);
  solveConstraints(blobs, params);
  applyPressure(blobs, params);
  applyBoundaryConstraints(blobs, bounds);
}
```

Export all functions. Do NOT include attraction springs yet (that's Phase 26 merge behavior).
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Create minimal test in `tests/softBody.test.ts`:
   - Test that `stepPhysics` doesn't throw with empty blob array
   - Test that `integrate` moves vertices with gravity
   - Test that `solveSpring` corrects stretched springs
  </verify>
  <done>Physics engine compiles, basic tests pass, all 6 core functions exported</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes
- [ ] `npm run test:run` passes (including new softBody tests)
- [ ] `src/core/softBody/types.ts` exports all interfaces
- [ ] `src/core/softBody/physics.ts` exports stepPhysics and sub-functions
- [ ] Vector utilities work correctly
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Physics engine is pure functions (no React, no side effects)
- Ready for Plan 25-02 to use these types/functions
</success_criteria>

<output>
After completion, create `.planning/phases/25-physics-foundation/25-01-SUMMARY.md`
</output>
