---
phase: 25-physics-foundation
plan: 02
type: execute
---

<objective>
Port blob creation from grid cells and create game integration hook.

Purpose: Connect the physics engine to actual game state so blobs can be created from grid cells.
Output: `core/softBody/blobFactory.ts` for blob creation, `hooks/useSoftBodyPhysics.ts` for game integration.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-physics-foundation/25-01-SUMMARY.md

**Source to port from:**
@prototypes/SoftBodyProto9.tsx (lines 180-541 for blob creation)

**Depends on Plan 25-01:**
@src/core/softBody/types.ts
@src/core/softBody/physics.ts

**Game coordinate system:**
@utils/coordinateTransform.ts (for BLOCK_SIZE, grid dimensions)

**Existing game state structure:**
@types.ts (TankCell, GoopGroupId)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Port blob creation from grid cells</name>
  <files>src/core/softBody/blobFactory.ts</files>
  <action>
Port perimeter tracing and blob creation from Proto-9 (lines 180-541):

**1. Constants (adapt from game):**
```typescript
import { BLOCK_SIZE } from '../../constants';

// Grid offset for physics space (pixels from SVG origin)
export const PHYSICS_GRID_OFFSET = { x: 50, y: 50 };  // Adjust based on game layout

// Cell size in physics space
export const PHYSICS_CELL_SIZE = BLOCK_SIZE;  // Should be ~30 based on game constants
```

**2. Find boundary edges:**
```typescript
interface Edge { x1: number; y1: number; x2: number; y2: number; }

export function findBoundaryEdges(cells: Vec2[]): Edge[] {
  const cellSet = new Set(cells.map(c => `${c.x},${c.y}`));
  const edges: Edge[] = [];

  for (const cell of cells) {
    // Check 4 neighbors - if missing, add that edge
    if (!cellSet.has(`${cell.x},${cell.y - 1}`)) {
      edges.push({ x1: cell.x, y1: cell.y, x2: cell.x + 1, y2: cell.y }); // Top
    }
    if (!cellSet.has(`${cell.x},${cell.y + 1}`)) {
      edges.push({ x1: cell.x + 1, y1: cell.y + 1, x2: cell.x, y2: cell.y + 1 }); // Bottom
    }
    if (!cellSet.has(`${cell.x - 1},${cell.y}`)) {
      edges.push({ x1: cell.x, y1: cell.y + 1, x2: cell.x, y2: cell.y }); // Left
    }
    if (!cellSet.has(`${cell.x + 1},${cell.y}`)) {
      edges.push({ x1: cell.x + 1, y1: cell.y, x2: cell.x + 1, y2: cell.y + 1 }); // Right
    }
  }
  return edges;
}
```

**3. Trace perimeter (right-hand rule):**
```typescript
export function tracePerimeter(edges: Edge[]): Vec2[] {
  if (edges.length === 0) return [];

  // Build adjacency map: point -> list of edges starting there
  const edgeMap = new Map<string, Edge[]>();
  for (const e of edges) {
    const key = `${e.x1},${e.y1}`;
    if (!edgeMap.has(key)) edgeMap.set(key, []);
    edgeMap.get(key)!.push(e);
  }

  const visited = new Set<string>();
  const perimeter: Vec2[] = [];

  let current = edges[0];
  const edgeKey = (e: Edge) => `${e.x1},${e.y1}-${e.x2},${e.y2}`;

  while (!visited.has(edgeKey(current))) {
    visited.add(edgeKey(current));
    perimeter.push({ x: current.x1, y: current.y1 });

    // Find next edge: starts at current's end point
    const nextKey = `${current.x2},${current.y2}`;
    const candidates = edgeMap.get(nextKey) || [];

    // Pick edge with largest clockwise turn (right-hand rule)
    const nextEdge = pickNextEdge(current, candidates, visited, edgeKey);
    if (!nextEdge) break;
    current = nextEdge;
  }

  return perimeter;
}

function pickNextEdge(current: Edge, candidates: Edge[], visited: Set<string>, edgeKey: (e: Edge) => string): Edge | null {
  // Calculate incoming direction
  const inDx = current.x2 - current.x1;
  const inDy = current.y2 - current.y1;
  const inAngle = Math.atan2(inDy, inDx);

  let best: Edge | null = null;
  let bestAngle = -Infinity;

  for (const candidate of candidates) {
    if (visited.has(edgeKey(candidate))) continue;

    const outDx = candidate.x2 - candidate.x1;
    const outDy = candidate.y2 - candidate.y1;
    const outAngle = Math.atan2(outDy, outDx);

    // Clockwise turn angle
    let turn = inAngle - outAngle;
    while (turn < 0) turn += Math.PI * 2;
    while (turn >= Math.PI * 2) turn -= Math.PI * 2;

    if (turn > bestAngle) {
      bestAngle = turn;
      best = candidate;
    }
  }

  return best;
}
```

**4. Convert to pixel coordinates:**
```typescript
export function gridToPixels(gridPoints: Vec2[]): Vec2[] {
  return gridPoints.map(p => ({
    x: PHYSICS_GRID_OFFSET.x + p.x * PHYSICS_CELL_SIZE,
    y: PHYSICS_GRID_OFFSET.y + p.y * PHYSICS_CELL_SIZE
  }));
}
```

**5. Check winding order (must be CCW for pressure):**
```typescript
export function ensureCCW(points: Vec2[]): Vec2[] {
  // Shoelace formula for signed area
  let signedArea = 0;
  for (let i = 0; i < points.length; i++) {
    const j = (i + 1) % points.length;
    signedArea += points[i].x * points[j].y;
    signedArea -= points[j].x * points[i].y;
  }
  signedArea /= 2;

  // Positive = CCW (correct), Negative = CW (reverse)
  return signedArea > 0 ? points : [...points].reverse();
}
```

**6. Create blob from cells:**
```typescript
export function createBlobFromCells(
  cells: Vec2[],
  color: string,
  id: string,
  isLocked: boolean
): SoftBlob {
  // 1. Find boundary and trace perimeter
  const edges = findBoundaryEdges(cells);
  const gridPerimeter = tracePerimeter(edges);
  const pixelPerimeter = gridToPixels(gridPerimeter);
  const points = ensureCCW(pixelPerimeter);

  // 2. Calculate centroid
  let cx = 0, cy = 0;
  for (const p of points) { cx += p.x; cy += p.y; }
  cx /= points.length;
  cy /= points.length;

  // 3. Create vertices with home offsets
  const vertices: Vertex[] = points.map(p => ({
    pos: { x: p.x, y: p.y },
    oldPos: { x: p.x, y: p.y },
    homeOffset: { x: p.x - cx, y: p.y - cy },
    mass: 1,
    attractionRadius: 0.8 + Math.random() * 0.4  // 0.8-1.2 variation
  }));

  // 4. Create ring springs (adjacent vertices)
  const ringsprings: Spring[] = [];
  for (let i = 0; i < vertices.length; i++) {
    const j = (i + 1) % vertices.length;
    ringsprings.push({
      a: i,
      b: j,
      restLength: vecDistance(vertices[i].pos, vertices[j].pos)
    });
  }

  // 5. Create cross springs (non-adjacent vertices < 1.5 cells apart)
  const crossSprings: Spring[] = [];
  const maxCrossDist = PHYSICS_CELL_SIZE * 1.5;
  for (let i = 0; i < vertices.length; i++) {
    for (let j = i + 2; j < vertices.length; j++) {
      if (j === (i + vertices.length - 1) % vertices.length) continue; // Skip adjacent
      const dist = vecDistance(vertices[i].pos, vertices[j].pos);
      if (dist < maxCrossDist) {
        crossSprings.push({ a: i, b: j, restLength: dist });
      }
    }
  }

  // 6. Calculate rest area (Shoelace)
  let restArea = 0;
  for (let i = 0; i < points.length; i++) {
    const j = (i + 1) % points.length;
    restArea += points[i].x * points[j].y - points[j].x * points[i].y;
  }
  restArea = Math.abs(restArea) / 2;

  // 7. Create inner vertices (stable core) - simplified: just centroid
  const innerVertices: Vertex[] = [{
    pos: { x: cx, y: cy },
    oldPos: { x: cx, y: cy },
    homeOffset: { x: 0, y: 0 },
    mass: 1,
    attractionRadius: 1
  }];

  return {
    id,
    color,
    vertices,
    innerVertices,
    ringsprings,
    crossSprings,
    restArea,
    gridCells: cells,
    isLocked,
    fillAmount: isLocked ? 0 : 1,  // Falling pieces start full
    rotation: 0,
    targetX: cx,
    targetY: cy,
    visualOffsetY: 0
  };
}
```

Export all functions.
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Add tests to `tests/softBody.test.ts`:
   - Test findBoundaryEdges with 2x2 cell block (should have 8 edges)
   - Test tracePerimeter produces closed loop
   - Test createBlobFromCells produces valid blob with springs
  </verify>
  <done>Blob factory compiles, creates valid blobs from grid cells, tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Create physics integration hook</name>
  <files>src/hooks/useSoftBodyPhysics.ts</files>
  <action>
Create a React hook that manages soft-body physics state and updates per frame:

```typescript
import { useRef, useCallback, useEffect } from 'react';
import { SoftBlob, PhysicsParams, DEFAULT_PHYSICS, Vec2 } from '../core/softBody/types';
import { stepPhysics } from '../core/softBody/physics';
import { createBlobFromCells, PHYSICS_GRID_OFFSET, PHYSICS_CELL_SIZE } from '../core/softBody/blobFactory';

interface UseSoftBodyPhysicsOptions {
  enabled: boolean;
  params?: Partial<PhysicsParams>;
  bounds?: { minX: number; maxX: number; minY: number; maxY: number };
}

interface UseSoftBodyPhysicsReturn {
  blobs: SoftBlob[];
  createBlob: (cells: Vec2[], color: string, id: string, isLocked: boolean) => SoftBlob;
  removeBlob: (id: string) => void;
  updateBlobTarget: (id: string, targetX: number, targetY: number) => void;
  lockBlob: (id: string) => void;
  step: (dt: number) => void;
}

export function useSoftBodyPhysics(options: UseSoftBodyPhysicsOptions): UseSoftBodyPhysicsReturn {
  const { enabled, params: paramOverrides, bounds } = options;

  const blobsRef = useRef<SoftBlob[]>([]);
  const paramsRef = useRef<PhysicsParams>({
    ...DEFAULT_PHYSICS,
    ...paramOverrides
  });

  // Default bounds based on game grid
  const boundsRef = useRef(bounds ?? {
    minX: PHYSICS_GRID_OFFSET.x,
    maxX: PHYSICS_GRID_OFFSET.x + 12 * PHYSICS_CELL_SIZE,  // Viewport width
    minY: PHYSICS_GRID_OFFSET.y,
    maxY: PHYSICS_GRID_OFFSET.y + 16 * PHYSICS_CELL_SIZE   // Viewport height
  });

  // Update params if they change
  useEffect(() => {
    paramsRef.current = { ...DEFAULT_PHYSICS, ...paramOverrides };
  }, [paramOverrides]);

  // Update bounds if they change
  useEffect(() => {
    if (bounds) boundsRef.current = bounds;
  }, [bounds]);

  const createBlob = useCallback((
    cells: Vec2[],
    color: string,
    id: string,
    isLocked: boolean
  ): SoftBlob => {
    const blob = createBlobFromCells(cells, color, id, isLocked);
    blobsRef.current = [...blobsRef.current, blob];
    return blob;
  }, []);

  const removeBlob = useCallback((id: string) => {
    blobsRef.current = blobsRef.current.filter(b => b.id !== id);
  }, []);

  const updateBlobTarget = useCallback((id: string, targetX: number, targetY: number) => {
    const blob = blobsRef.current.find(b => b.id === id);
    if (blob) {
      blob.targetX = targetX;
      blob.targetY = targetY;
    }
  }, []);

  const lockBlob = useCallback((id: string) => {
    const blob = blobsRef.current.find(b => b.id === id);
    if (blob) {
      blob.isLocked = true;
      blob.fillAmount = 0;  // Start fill animation
    }
  }, []);

  const step = useCallback((dt: number) => {
    if (!enabled || blobsRef.current.length === 0) return;
    stepPhysics(blobsRef.current, dt, paramsRef.current, boundsRef.current);
  }, [enabled]);

  return {
    blobs: blobsRef.current,
    createBlob,
    removeBlob,
    updateBlobTarget,
    lockBlob,
    step
  };
}
```

**Key design decisions:**
- Uses refs for mutable state (avoids re-renders on every physics tick)
- `step()` called externally from game loop (doesn't create its own animation frame)
- `enabled` flag allows disabling physics without unmounting
- Returns current blobs array for rendering (Phase 26 will use this)

Also create index file for clean imports:
```typescript
// src/core/softBody/index.ts
export * from './types';
export * from './physics';
export * from './blobFactory';
```
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Add hook test to `tests/softBody.test.ts`:
   - Test createBlob adds to blobs array
   - Test removeBlob removes from array
   - Test step doesn't throw when enabled
  </verify>
  <done>Hook compiles, manages blob lifecycle, integrates with physics engine, tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes
- [ ] `npm run test:run` passes (all softBody tests)
- [ ] Blob factory creates valid blobs from grid cells
- [ ] Hook manages blob lifecycle (create, remove, update, lock)
- [ ] Physics step integrates smoothly
- [ ] Index file provides clean exports
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Phase 25 Physics Foundation complete
- Ready for Phase 26 to render blobs with cylindrical projection
</success_criteria>

<output>
After completion, create `.planning/phases/25-physics-foundation/25-02-SUMMARY.md` with:
- RED-GREEN summary of blob factory
- Integration hook architecture
- Phase 25 complete status
</output>
