---
phase: 27-active-piece-physics
plan: 01
type: execute
---

<objective>
Wire up soft-body blob lifecycle for the active falling piece.

Purpose: Enable falling pieces to use soft-body physics, which will transmit impact force to locked goop on landing and allow proper testing of stiffness/collision behavior.

Output: Falling pieces create SBG blobs on spawn, sync position while falling, and transition to locked state properly. Visual rendering comes in plan 02.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26.1-flatten-coordinate-system/26.1-FIX-SUMMARY.md

**Key source files:**
@hooks/useSoftBodyPhysics.ts
@core/softBody/blobFactory.ts
@core/GameEngine.ts
@Game.tsx
@components/GameBoard.tsx

**Context from prior phases:**
- Phase 26.1 established the soft-body system for locked goop
- `createBlob(cells, color, id, isLocked=false)` already supports falling blobs
- `updateBlobTarget(id, x, y)` already exists for position sync
- `lockBlob(id)` already transitions falling → locked state
- Coordinate system uses PHYSICS_GRID_OFFSET and PHYSICS_CELL_SIZE for pixel conversion

**Key insight from STATE.md:**
The remaining stiffness issues (UAT-001, UAT-002) can't be fully tested until the falling piece uses SBG. Without impact force on landing, locked goop won't jiggle.

**Coordinate conversion:**
- Grid (gx, gy) → Pixel: `(PHYSICS_GRID_OFFSET.x + gx * PHYSICS_CELL_SIZE, PHYSICS_GRID_OFFSET.y + gy * PHYSICS_CELL_SIZE)`
- PHYSICS_GRID_OFFSET = {x: -180, y: 0}
- PHYSICS_CELL_SIZE = 30
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create falling blob on piece spawn</name>
  <files>components/GameBoard.tsx</files>
  <action>
Add logic to create a soft-body blob when a new active piece spawns (not locked):

1. In the existing useEffect that syncs locked goop blobs (around line 190-220), add a NEW useEffect specifically for the active piece:

```typescript
// Sync active piece with soft-body blob (falling state)
useEffect(() => {
  if (!softBodyPhysics || isMobile) return;
  if (!activeGoop || activeGoop.state !== GoopState.FALLING) return;

  const blobId = `active-${activeGoop.id ?? 'piece'}`;
  const existingBlob = softBodyPhysics.getBlob(blobId);

  // Create blob if it doesn't exist
  if (!existingBlob) {
    // Convert piece cells to absolute grid coordinates
    const cells = activeGoop.cells.map(cell => ({
      x: activeGoop.x + cell.x,
      y: activeGoop.y + cell.y
    }));

    // Get color (handle multi-color pieces by using first cell color)
    const color = activeGoop.definition.cellColors?.[0] ?? activeGoop.definition.color;

    softBodyPhysics.createBlob(cells, color, blobId, false, tankRotation);
  }
}, [activeGoop?.id, softBodyPhysics, isMobile, tankRotation]);
```

Key decisions:
- Use `active-` prefix for blob ID to distinguish from locked goop blobs
- Create blob only when state is FALLING (not during other states)
- Handle multi-color pieces by using first cell color (visual simplification)

What to avoid and WHY:
- Don't create blob in every render — only when piece ID changes
- Don't use activeGoop.x/y directly for cells — add to cell offsets for absolute coords
  </action>
  <verify>
Manual: Start game, piece spawns, check console for no errors.
Check softBodyPhysics.blobs array includes an "active-*" blob.
  </verify>
  <done>Falling blob created on piece spawn with correct cells and position</done>
</task>

<task type="auto">
  <name>Task 2: Sync blob position every frame</name>
  <files>components/GameBoard.tsx</files>
  <action>
Add position sync to update the falling blob's target position each frame as the piece falls:

1. In the same useEffect (or a separate one triggered on position change), sync position:

```typescript
// Update blob position every frame while falling
useEffect(() => {
  if (!softBodyPhysics || isMobile) return;
  if (!activeGoop || activeGoop.state !== GoopState.FALLING) return;

  const blobId = `active-${activeGoop.id ?? 'piece'}`;
  const blob = softBodyPhysics.getBlob(blobId);
  if (!blob) return;

  // Convert grid position to pixel position for physics
  // Use the piece's center cell for target
  const centerX = activeGoop.x;
  const centerY = activeGoop.y;

  // Grid to pixel: PHYSICS_GRID_OFFSET + grid * PHYSICS_CELL_SIZE
  const targetX = PHYSICS_GRID_OFFSET.x + centerX * PHYSICS_CELL_SIZE + PHYSICS_CELL_SIZE / 2;
  const targetY = PHYSICS_GRID_OFFSET.y + centerY * PHYSICS_CELL_SIZE + PHYSICS_CELL_SIZE / 2;

  softBodyPhysics.updateBlobTarget(blobId, targetX, targetY);
}, [activeGoop?.x, activeGoop?.y, activeGoop?.state, softBodyPhysics, isMobile]);
```

Note: Import PHYSICS_GRID_OFFSET and PHYSICS_CELL_SIZE from core/softBody/blobFactory.

2. Also update cell positions when the piece moves/rotates. The blob's home positions need to stay synced with piece cells:

Add to useSoftBodyPhysics hook (hooks/useSoftBodyPhysics.ts):
```typescript
/**
 * Update a blob's cells (for when piece rotates or shape changes).
 * Recalculates vertices based on new cell positions.
 */
const updateBlobCells = useCallback((id: string, cells: Vec2[], gridOffsetX: number, gridOffsetY: number) => {
  const blob = blobsRef.current.find(b => b.id === id);
  if (!blob || blob.isLocked) return; // Only update falling blobs

  // For now, just update target position based on new cell centroid
  // Full vertex recalculation would be expensive and may not be needed
  let sumX = 0, sumY = 0;
  for (const cell of cells) {
    sumX += gridOffsetX + cell.x;
    sumY += gridOffsetY + cell.y;
  }
  const cx = sumX / cells.length;
  const cy = sumY / cells.length;

  blob.targetX = PHYSICS_GRID_OFFSET.x + (cx + 0.5) * PHYSICS_CELL_SIZE;
  blob.targetY = PHYSICS_GRID_OFFSET.y + (cy + 0.5) * PHYSICS_CELL_SIZE;
}, []);
```

Actually, simpler approach: Just update target position. The home forces will pull vertices toward target position. No need to recalculate vertices for rotation — the soft body will naturally deform.

What to avoid and WHY:
- Don't recalculate all vertices on every move — expensive and unnecessary
- Don't wrap positions here — let physics handle wrapping
  </action>
  <verify>
Manual: Start game, watch piece fall. Blob position should track piece position.
Console: softBodyPhysics.getBlob('active-...')?.targetY should decrease as piece falls.
  </verify>
  <done>Blob position syncs with piece movement every frame</done>
</task>

<task type="auto">
  <name>Task 3: Handle lock transition and cleanup</name>
  <files>components/GameBoard.tsx, hooks/useSoftBodyPhysics.ts</files>
  <action>
Handle the transition when a piece locks and cleanup when piece is cleared:

1. In GameBoard.tsx, detect when activeGoop changes from FALLING to null (piece locked):

```typescript
// Track previous activeGoop to detect lock transitions
const prevActiveGoopRef = useRef<typeof activeGoop>(null);

useEffect(() => {
  if (!softBodyPhysics || isMobile) return;

  const prevPiece = prevActiveGoopRef.current;
  const currPiece = activeGoop;

  // Piece locked: was falling, now null or new piece
  if (prevPiece && prevPiece.state === GoopState.FALLING &&
      (!currPiece || currPiece.id !== prevPiece.id)) {
    const blobId = `active-${prevPiece.id ?? 'piece'}`;

    // Remove the falling blob — locked goop sync will create a new blob for locked cells
    softBodyPhysics.removeBlob(blobId);
  }

  prevActiveGoopRef.current = currPiece;
}, [activeGoop, softBodyPhysics, isMobile]);
```

Key insight: When a piece locks, the existing locked-goop sync logic (around line 190-220) will automatically create blobs for the newly locked cells. We just need to REMOVE the falling blob to avoid duplicates.

Alternative approach (if visual continuity is important): Instead of remove + recreate, we could rename the blob and call lockBlob(). But simpler to just remove and let the standard sync handle it.

2. Also handle game reset (clearBlobs is already called on game state reset via Game.tsx):

No changes needed — clearBlobs() already exists and is called when game resets.

What to avoid and WHY:
- Don't call lockBlob() on the active blob AND let the standard sync create a new one — that would create duplicate blobs
- Don't keep the falling blob around after lock — it would render twice
  </action>
  <verify>
Manual:
1. Start game, let piece fall and lock
2. Check softBodyPhysics.blobs - should have NO "active-" blob after lock
3. Should have a locked blob for the newly placed cells (created by standard sync)
4. No duplicate blobs visible
  </verify>
  <done>Falling blob removed on lock, no duplicate blobs, clean transition</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run test:run` passes all tests
- [ ] `npm run dev -- --host` starts without errors
- [ ] Console shows no errors during piece spawn/fall/lock cycle
- [ ] softBodyPhysics.blobs contains "active-*" blob while piece falling
- [ ] softBodyPhysics.blobs does NOT contain "active-*" blob after piece locks
- [ ] No duplicate blobs (one per goopGroupId)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Falling pieces create soft-body blobs on spawn
- Blob position syncs with piece movement
- Clean transition from falling to locked (no duplicates)
- Ready for rendering switch in plan 02
</success_criteria>

<output>
After completion, create `.planning/phases/27-active-piece-physics/27-01-SUMMARY.md`:

# Phase 27 Plan 01: Active Piece Physics Integration Summary

**[Substantive one-liner describing what shipped]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description

## Decisions Made

[Key decisions and rationale]

## Issues Encountered

[Problems and resolutions]

## Next Step

Ready for 27-02-PLAN.md (rendering switch)
</output>
